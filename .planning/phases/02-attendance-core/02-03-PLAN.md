---
phase: 02-attendance-core
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - apps/web/package.json
  - apps/web/src/components/attendance/AttendanceStatusCard.tsx
  - apps/web/src/components/attendance/CheckInModal.tsx
  - apps/web/src/components/attendance/CheckOutModal.tsx
  - apps/web/src/components/attendance/BreakButton.tsx
  - apps/web/src/hooks/useAttendance.ts
autonomous: true

must_haves:
  truths:
    - "User sees full status card with live timer when checked in"
    - "User can check in via modal with work mode selection"
    - "User can check out via modal with optional note"
    - "User can start/end breaks with single click"
    - "Break policy indicator shows usage against limit"
  artifacts:
    - path: "apps/web/src/components/attendance/AttendanceStatusCard.tsx"
      provides: "Full status card component"
      min_lines: 100
    - path: "apps/web/src/components/attendance/CheckInModal.tsx"
      provides: "Work mode selection modal"
      min_lines: 50
    - path: "apps/web/src/hooks/useAttendance.ts"
      provides: "Attendance state hook"
      exports: ["useAttendance"]
  key_links:
    - from: "AttendanceStatusCard.tsx"
      to: "useAttendance.ts"
      via: "hook import"
      pattern: "useAttendance"
    - from: "useAttendance.ts"
      to: "/api/attendance"
      via: "fetch calls"
      pattern: "api.post.*attendance"
---

<objective>
Build the frontend attendance components: status card, check-in modal, check-out modal, and break button.

Purpose: Per CONTEXT.md, user needs a full status card during active session showing timer, mode badge, break button, today's total hours, and break time taken. Modals provide structured check-in/out flow.

Output: Complete component library for attendance workflow that integrates with dashboard.
</objective>

<execution_context>
@/Users/adityaw/.claude/get-shit-done/workflows/execute-plan.md
@/Users/adityaw/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-attendance-core/02-CONTEXT.md
@.planning/phases/02-attendance-core/02-RESEARCH.md
@apps/web/src/app/dashboard/page.tsx
@apps/web/src/lib/api.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install date-fns and create useAttendance hook</name>
  <files>apps/web/package.json, apps/web/src/hooks/useAttendance.ts</files>
  <action>
1. Install date-fns:
```bash
npm install date-fns --workspace=apps/web
```

2. Create useAttendance hook at `apps/web/src/hooks/useAttendance.ts`:

```typescript
import { useState, useEffect, useCallback } from 'react';
import { api } from '@/lib/api';

export type AttendanceStatus = 'not_checked_in' | 'working' | 'on_break' | 'checked_out';
export type WorkMode = 'Office' | 'Remote' | 'CustomerSite' | 'FieldVisit';
export type BreakType = 'Break' | 'Lunch';

export interface AttendanceState {
  status: AttendanceStatus;
  checkInTime: string | null;
  checkOutTime: string | null;
  workMode: WorkMode | null;
  currentBreak: { id: string; type: BreakType; startTime: string } | null;
  totalWorkMinutes: number;
  totalBreakMinutes: number;
  overtimeMinutes: number;
  events: any[];
  breaks: any[];
  policy: {
    breakDurationMinutes: number;
    lunchDurationMinutes: number;
    overtimeThresholdMinutes: number;
  } | null;
}

export function useAttendance() {
  const [state, setState] = useState<AttendanceState>({
    status: 'not_checked_in',
    checkInTime: null,
    checkOutTime: null,
    workMode: null,
    currentBreak: null,
    totalWorkMinutes: 0,
    totalBreakMinutes: 0,
    overtimeMinutes: 0,
    events: [],
    breaks: [],
    policy: null,
  });
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchToday = useCallback(async () => {
    try {
      const res = await api.get('/attendance/today');
      if (res.success && res.data) {
        setState(mapApiResponse(res.data));
      } else {
        setState(prev => ({ ...prev, status: 'not_checked_in' }));
      }
    } catch (err) {
      setError('Failed to fetch attendance');
    } finally {
      setIsLoading(false);
    }
  }, []);

  const checkIn = async (workMode: WorkMode) => {
    setError(null);
    const res = await api.post('/attendance/check-in', { workMode, latitude: 0, longitude: 0 });
    if (res.success) {
      setState(mapApiResponse(res.data.attendanceDay));
      return true;
    }
    setError(res.error?.message || 'Check-in failed');
    return false;
  };

  const checkOut = async (notes?: string) => {
    setError(null);
    const res = await api.post('/attendance/check-out', { notes, latitude: 0, longitude: 0 });
    if (res.success) {
      setState(mapApiResponse(res.data.attendanceDay));
      return res.data;
    }
    setError(res.error?.message || 'Check-out failed');
    return null;
  };

  const startBreak = async (type: BreakType = 'Break') => {
    setError(null);
    const res = await api.post('/attendance/break/start', { type });
    if (res.success) {
      await fetchToday();
      return true;
    }
    setError(res.error?.message || 'Failed to start break');
    return false;
  };

  const endBreak = async () => {
    if (!state.currentBreak) return false;
    setError(null);
    const res = await api.post(`/attendance/break/${state.currentBreak.id}/end`, {});
    if (res.success) {
      await fetchToday();
      return true;
    }
    setError(res.error?.message || 'Failed to end break');
    return false;
  };

  useEffect(() => {
    fetchToday();
  }, [fetchToday]);

  // Refresh on visibility change
  useEffect(() => {
    const handleVisibility = () => {
      if (document.visibilityState === 'visible') {
        fetchToday();
      }
    };
    document.addEventListener('visibilitychange', handleVisibility);
    return () => document.removeEventListener('visibilitychange', handleVisibility);
  }, [fetchToday]);

  return {
    ...state,
    isLoading,
    error,
    checkIn,
    checkOut,
    startBreak,
    endBreak,
    refresh: fetchToday,
  };
}

function mapApiResponse(data: any): AttendanceState {
  // Map API response to state shape
  // Handle null/undefined gracefully
  return {
    status: data?.status || 'not_checked_in',
    checkInTime: data?.checkInTime || null,
    checkOutTime: data?.checkOutTime || null,
    workMode: data?.workMode || null,
    currentBreak: data?.currentBreak || null,
    totalWorkMinutes: data?.totalWorkMinutes || 0,
    totalBreakMinutes: data?.totalBreakMinutes || 0,
    overtimeMinutes: data?.overtimeMinutes || 0,
    events: data?.events || [],
    breaks: data?.breaks || [],
    policy: data?.policy || null,
  };
}
```
  </action>
  <verify>
Run `npm run build --workspace=apps/web` - no TypeScript errors.
  </verify>
  <done>
date-fns installed. useAttendance hook exports all methods and state.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create CheckInModal and CheckOutModal</name>
  <files>apps/web/src/components/attendance/CheckInModal.tsx, apps/web/src/components/attendance/CheckOutModal.tsx</files>
  <action>
Create `apps/web/src/components/attendance/CheckInModal.tsx`:
- Modal overlay with framer-motion animation
- 4 work mode options: Office, Remote, Field, Client Site (per CONTEXT.md)
- Each option is a button/card with icon and label
- Clicking option calls onCheckIn(workMode) and closes modal
- ESC key and backdrop click close modal
- Use Lucide icons: Building2 (Office), Home (Remote), MapPin (Field), Briefcase (Client Site)

Create `apps/web/src/components/attendance/CheckOutModal.tsx`:
- Modal overlay with framer-motion animation
- Shows summary of day: work time, break time
- Warning if break is currently open: "You have an open break that will be ended"
- Optional notes textarea
- Cancel and "Check Out" buttons
- Confirm button calls onCheckOut(notes)
  </action>
  <verify>
Run `npm run build --workspace=apps/web` - no TypeScript errors.
  </verify>
  <done>
Both modals render with correct UX per CONTEXT.md. Animations smooth. Keyboard accessible.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create AttendanceStatusCard with BreakButton</name>
  <files>apps/web/src/components/attendance/AttendanceStatusCard.tsx, apps/web/src/components/attendance/BreakButton.tsx, apps/web/src/components/attendance/BreakPolicyIndicator.tsx</files>
  <action>
Create `apps/web/src/components/attendance/BreakButton.tsx`:
- Single button that toggles between "Start Break" and "End Break"
- Shows break duration timer when on break
- Loading state during API call
- Uses Coffee icon from Lucide

Create `apps/web/src/components/attendance/BreakPolicyIndicator.tsx`:
- Progress bar showing break time used vs policy limit
- Green when under limit, yellow approaching, red exceeded
- Shows "Xm / Ym" text

Create `apps/web/src/components/attendance/AttendanceStatusCard.tsx`:
- Full status card per CONTEXT.md decisions:
  - Large clock icon with status color
  - Timer showing elapsed time since check-in (uses date-fns intervalToDuration)
  - Work mode badge
  - Break button
  - Stats row: Work time, Break time, Target (8h), Remaining/Overtime
  - Break policy indicator
- Handles all states: not_checked_in, working, on_break, checked_out
- "Check In" button when not checked in, opens CheckInModal
- "Check Out" button when checked in, opens CheckOutModal
- Disable check-out while on break (per RESEARCH.md anti-pattern avoidance)

Timer updates every second client-side (not via API polling).
  </action>
  <verify>
Run `npm run build --workspace=apps/web` - no TypeScript errors.
  </verify>
  <done>
AttendanceStatusCard renders all states correctly. Timer updates live. Break policy indicator shows usage.
  </done>
</task>

</tasks>

<verification>
1. Build passes: `npm run build --workspace=apps/web`
2. Visual check: Components render in Storybook or dashboard
3. Interaction test:
   - Open check-in modal, select work mode, verify closes and state updates
   - See live timer counting up
   - Start break, see break timer
   - End break, see totals update
   - Check out with note, see summary
</verification>

<success_criteria>
- All components exist in apps/web/src/components/attendance/
- useAttendance hook manages all state
- Timer updates every second without API calls
- Modals have smooth animations
- Break policy indicator reflects actual policy from API
</success_criteria>

<output>
After completion, create `.planning/phases/02-attendance-core/02-03-SUMMARY.md`
</output>
