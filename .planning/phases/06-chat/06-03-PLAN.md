---
phase: 06-chat
plan: 03
type: execute
wave: 3
depends_on: ["06-01", "06-02"]
files_modified:
  - apps/web/src/store/chat.ts
  - apps/web/src/hooks/useChat.ts
  - apps/web/src/hooks/index.ts
autonomous: true

must_haves:
  truths:
    - "Chat store connects to /chat WebSocket namespace"
    - "Sending message via socket emits event and shows optimistically"
    - "Incoming messages update conversation list and active thread"
    - "Read receipts update message status in store"
  artifacts:
    - path: "apps/web/src/store/chat.ts"
      provides: "Zustand store with Socket.IO chat integration"
      contains: "useChatStore"
    - path: "apps/web/src/hooks/useChat.ts"
      provides: "Hook for chat operations with auto-connect"
      exports: ["useChat"]
  key_links:
    - from: "apps/web/src/store/chat.ts"
      to: "io(`${API_URL}/chat`"
      via: "Socket.IO connection to chat namespace"
      pattern: "io\\(.*/chat"
    - from: "apps/web/src/store/chat.ts"
      to: "socket.emit('chat:send'"
      via: "Send message via WebSocket"
      pattern: "emit\\('chat:send'"
    - from: "apps/web/src/hooks/useChat.ts"
      to: "useChatStore"
      via: "Hook uses store for state and actions"
      pattern: "useChatStore"
---

<objective>
Create Zustand chat store with Socket.IO integration and useChat hook for frontend chat operations.

Purpose: Provide frontend state management for real-time chat per CHAT-03, CHAT-04, CHAT-05 requirements. Enable instant message delivery and status tracking.

Output: Chat store following presence store pattern, useChat hook with auto-connect and message operations.
</objective>

<execution_context>
@/Users/adityaw/.claude/get-shit-done/workflows/execute-plan.md
@/Users/adityaw/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-chat/06-CONTEXT.md
@.planning/phases/06-chat/06-RESEARCH.md
@.planning/phases/06-chat/06-01-SUMMARY.md
@.planning/phases/06-chat/06-02-SUMMARY.md

@apps/web/src/store/presence.ts
@apps/web/src/hooks/usePresence.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Zustand chat store with Socket.IO integration</name>
  <files>apps/web/src/store/chat.ts</files>
  <action>
Create chat store following the presence store pattern. Key differences:
- Uses /chat namespace instead of /presence
- Manages conversations and messages (Map-based)
- Handles typing indicators per thread
- Tracks message statuses for read receipts

```typescript
/**
 * Chat Store
 *
 * Manages real-time chat state using Zustand with Socket.IO integration.
 * Handles conversations, messages, typing indicators, and delivery/read status.
 */

'use client';

import { create } from 'zustand';
import { io, Socket } from 'socket.io-client';

// Types
export type MessageStatus = 'sending' | 'sent' | 'delivered' | 'read' | 'failed';

export interface MessageRecipientStatus {
  userId: string;
  deliveredAt?: string;
  readAt?: string;
}

export interface ChatMessage {
  id: string;
  threadId: string;
  senderId: string;
  type: 'Text' | 'File' | 'Image' | 'Voice' | 'Location';
  content?: string | null;
  attachmentUrl?: string | null;
  attachmentType?: string | null;
  isEdited: boolean;
  editedAt?: string | null;
  deletedAt?: string | null;
  createdAt: string;
  sender: {
    id: string;
    email: string;
    profile?: {
      firstName: string;
      lastName: string;
      avatarUrl?: string;
    } | null;
  };
  statuses?: MessageRecipientStatus[];
  // Client-side tracking
  tempId?: string;
  clientStatus?: MessageStatus;
}

export interface Conversation {
  id: string;
  type: 'Direct' | 'Group' | 'Project';
  name?: string | null;
  projectId?: string | null;
  lastMessageAt?: string | null;
  unreadCount: number;
  members: {
    userId: string;
    user: {
      id: string;
      email: string;
      profile?: {
        firstName: string;
        lastName: string;
        avatarUrl?: string;
      } | null;
    };
  }[];
  messages?: ChatMessage[]; // Last message for preview
}

interface ChatState {
  // Connection state
  socket: Socket | null;
  isConnected: boolean;
  connectionError: string | null;

  // Conversations
  conversations: Conversation[];
  activeConversationId: string | null;
  isLoadingConversations: boolean;

  // Messages (per conversation)
  messages: Map<string, ChatMessage[]>;
  hasMoreMessages: Map<string, boolean>;
  isLoadingMessages: boolean;

  // Typing indicators (threadId -> userIds)
  typingUsers: Map<string, Set<string>>;

  // Actions - Connection
  connect: (token: string) => void;
  disconnect: () => void;

  // Actions - Conversations
  setConversations: (conversations: Conversation[]) => void;
  setActiveConversation: (conversationId: string | null) => void;
  addConversation: (conversation: Conversation) => void;
  updateUnreadCount: (threadId: string, count: number) => void;

  // Actions - Messages
  setMessages: (threadId: string, messages: ChatMessage[], hasMore: boolean) => void;
  addMessage: (threadId: string, message: ChatMessage) => void;
  updateMessage: (threadId: string, messageId: string, updates: Partial<ChatMessage>) => void;
  prependMessages: (threadId: string, messages: ChatMessage[], hasMore: boolean) => void;

  // Actions - Socket operations
  sendMessage: (threadId: string, content: string, type?: string) => Promise<void>;
  markAsRead: (threadId: string) => void;
  startTyping: (threadId: string) => void;
  stopTyping: (threadId: string) => void;
  joinThread: (threadId: string) => void;

  // Actions - Loading states
  setLoadingConversations: (loading: boolean) => void;
  setLoadingMessages: (loading: boolean) => void;
}

const API_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001';

export const useChatStore = create<ChatState>((set, get) => ({
  // Initial state
  socket: null,
  isConnected: false,
  connectionError: null,
  conversations: [],
  activeConversationId: null,
  isLoadingConversations: false,
  messages: new Map(),
  hasMoreMessages: new Map(),
  isLoadingMessages: false,
  typingUsers: new Map(),

  connect: (token: string) => {
    const existingSocket = get().socket;
    if (existingSocket?.connected) {
      return; // Already connected
    }

    // Disconnect existing socket if any
    existingSocket?.disconnect();

    const socket = io(`${API_URL}/chat`, {
      auth: { token },
      autoConnect: true,
      reconnection: true,
      reconnectionAttempts: 5,
      reconnectionDelay: 1000,
      reconnectionDelayMax: 5000,
    });

    // Connection events
    socket.on('connect', () => {
      console.log('[Chat] Connected to server');
      set({ isConnected: true, connectionError: null });
    });

    socket.on('disconnect', (reason) => {
      console.log('[Chat] Disconnected:', reason);
      set({ isConnected: false });
    });

    socket.on('connect_error', (error) => {
      console.error('[Chat] Connection error:', error.message);
      set({ connectionError: error.message, isConnected: false });
    });

    // Message events
    socket.on('chat:message', (data: { threadId: string; message: ChatMessage; tempId?: string }) => {
      const { activeConversationId, messages } = get();

      // Update or add message
      set((state) => {
        const threadMessages = state.messages.get(data.threadId) || [];

        // Check for duplicate (by tempId or id)
        const existingIndex = threadMessages.findIndex(
          (m) => m.id === data.message.id || (data.tempId && m.tempId === data.tempId)
        );

        let newMessages: ChatMessage[];
        if (existingIndex >= 0) {
          // Update existing (was optimistic)
          newMessages = [...threadMessages];
          newMessages[existingIndex] = { ...data.message, clientStatus: 'sent' };
        } else {
          // Add new
          newMessages = [...threadMessages, { ...data.message, clientStatus: 'sent' }];
        }

        // Update conversation preview
        const conversations = state.conversations.map((c) =>
          c.id === data.threadId
            ? {
                ...c,
                lastMessageAt: data.message.createdAt,
                messages: [data.message],
                unreadCount: c.id === activeConversationId ? 0 : c.unreadCount + 1,
              }
            : c
        );

        // Sort conversations by lastMessageAt
        conversations.sort((a, b) => {
          const aTime = a.lastMessageAt ? new Date(a.lastMessageAt).getTime() : 0;
          const bTime = b.lastMessageAt ? new Date(b.lastMessageAt).getTime() : 0;
          return bTime - aTime;
        });

        return {
          messages: new Map(state.messages).set(data.threadId, newMessages),
          conversations,
        };
      });

      // Auto-mark as delivered if we're the recipient and message is from someone else
      const currentUserId = socket.id; // Note: We need to track actual userId
      if (data.message.senderId !== currentUserId) {
        socket.emit('chat:delivered', {
          threadId: data.threadId,
          messageIds: [data.message.id],
        });
      }
    });

    // Delivery receipt (our sent message was delivered)
    socket.on('chat:delivered', (data: { threadId: string; messageIds: string[]; userId: string; timestamp: string }) => {
      set((state) => {
        const threadMessages = state.messages.get(data.threadId);
        if (!threadMessages) return state;

        const newMessages = threadMessages.map((m) => {
          if (data.messageIds.includes(m.id)) {
            return { ...m, clientStatus: 'delivered' as MessageStatus };
          }
          return m;
        });

        return {
          messages: new Map(state.messages).set(data.threadId, newMessages),
        };
      });
    });

    // Read receipt (our sent message was read)
    socket.on('chat:read', (data: { threadId: string; messageIds: string[]; userId: string; timestamp: string }) => {
      set((state) => {
        const threadMessages = state.messages.get(data.threadId);
        if (!threadMessages) return state;

        const newMessages = threadMessages.map((m) => {
          if (data.messageIds.includes(m.id)) {
            return { ...m, clientStatus: 'read' as MessageStatus };
          }
          return m;
        });

        return {
          messages: new Map(state.messages).set(data.threadId, newMessages),
        };
      });
    });

    // Message edited
    socket.on('chat:message:edited', (data: { threadId: string; message: ChatMessage }) => {
      set((state) => {
        const threadMessages = state.messages.get(data.threadId);
        if (!threadMessages) return state;

        const newMessages = threadMessages.map((m) =>
          m.id === data.message.id ? { ...m, ...data.message } : m
        );

        return {
          messages: new Map(state.messages).set(data.threadId, newMessages),
        };
      });
    });

    // Message deleted
    socket.on('chat:message:deleted', (data: { threadId: string; messageId: string }) => {
      set((state) => {
        const threadMessages = state.messages.get(data.threadId);
        if (!threadMessages) return state;

        const newMessages = threadMessages.map((m) =>
          m.id === data.messageId
            ? { ...m, deletedAt: new Date().toISOString(), content: null, attachmentUrl: null }
            : m
        );

        return {
          messages: new Map(state.messages).set(data.threadId, newMessages),
        };
      });
    });

    // New thread created (we were added to a conversation)
    socket.on('chat:thread:created', (data: { thread: Conversation }) => {
      set((state) => ({
        conversations: [data.thread, ...state.conversations],
      }));
      // Join the new thread room
      socket.emit('chat:join', { threadId: data.thread.id });
    });

    // Typing indicators
    socket.on('chat:typing:start', (data: { threadId: string; userId: string }) => {
      set((state) => {
        const threadTyping = new Set(state.typingUsers.get(data.threadId) || []);
        threadTyping.add(data.userId);
        return {
          typingUsers: new Map(state.typingUsers).set(data.threadId, threadTyping),
        };
      });

      // Auto-clear after 5 seconds if no stop received
      setTimeout(() => {
        set((state) => {
          const threadTyping = new Set(state.typingUsers.get(data.threadId) || []);
          threadTyping.delete(data.userId);
          return {
            typingUsers: new Map(state.typingUsers).set(data.threadId, threadTyping),
          };
        });
      }, 5000);
    });

    socket.on('chat:typing:stop', (data: { threadId: string; userId: string }) => {
      set((state) => {
        const threadTyping = new Set(state.typingUsers.get(data.threadId) || []);
        threadTyping.delete(data.userId);
        return {
          typingUsers: new Map(state.typingUsers).set(data.threadId, threadTyping),
        };
      });
    });

    set({ socket });
  },

  disconnect: () => {
    const { socket } = get();
    if (socket) {
      socket.disconnect();
      set({
        socket: null,
        isConnected: false,
        messages: new Map(),
        typingUsers: new Map(),
      });
    }
  },

  // Conversation actions
  setConversations: (conversations: Conversation[]) => {
    set({ conversations });
  },

  setActiveConversation: (conversationId: string | null) => {
    set({ activeConversationId: conversationId });

    // Mark as read when switching to conversation
    if (conversationId) {
      const { socket, conversations } = get();
      if (socket?.connected) {
        socket.emit('chat:mark-read', { threadId: conversationId });
      }

      // Reset unread count locally
      set((state) => ({
        conversations: state.conversations.map((c) =>
          c.id === conversationId ? { ...c, unreadCount: 0 } : c
        ),
      }));
    }
  },

  addConversation: (conversation: Conversation) => {
    set((state) => ({
      conversations: [conversation, ...state.conversations],
    }));

    // Join room
    const { socket } = get();
    if (socket?.connected) {
      socket.emit('chat:join', { threadId: conversation.id });
    }
  },

  updateUnreadCount: (threadId: string, count: number) => {
    set((state) => ({
      conversations: state.conversations.map((c) =>
        c.id === threadId ? { ...c, unreadCount: count } : c
      ),
    }));
  },

  // Message actions
  setMessages: (threadId: string, messages: ChatMessage[], hasMore: boolean) => {
    set((state) => ({
      messages: new Map(state.messages).set(threadId, messages),
      hasMoreMessages: new Map(state.hasMoreMessages).set(threadId, hasMore),
    }));
  },

  addMessage: (threadId: string, message: ChatMessage) => {
    set((state) => {
      const existing = state.messages.get(threadId) || [];
      return {
        messages: new Map(state.messages).set(threadId, [...existing, message]),
      };
    });
  },

  updateMessage: (threadId: string, messageId: string, updates: Partial<ChatMessage>) => {
    set((state) => {
      const existing = state.messages.get(threadId) || [];
      return {
        messages: new Map(state.messages).set(
          threadId,
          existing.map((m) => (m.id === messageId || m.tempId === messageId ? { ...m, ...updates } : m))
        ),
      };
    });
  },

  prependMessages: (threadId: string, messages: ChatMessage[], hasMore: boolean) => {
    set((state) => {
      const existing = state.messages.get(threadId) || [];
      return {
        messages: new Map(state.messages).set(threadId, [...messages, ...existing]),
        hasMoreMessages: new Map(state.hasMoreMessages).set(threadId, hasMore),
      };
    });
  },

  // Socket operations
  sendMessage: async (threadId: string, content: string, type = 'Text') => {
    const { socket, isConnected } = get();
    if (!socket || !isConnected) {
      throw new Error('Not connected to chat server');
    }

    // Generate temp ID for optimistic update
    const tempId = `temp-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

    // Optimistic update
    const optimisticMessage: ChatMessage = {
      id: tempId,
      threadId,
      senderId: '', // Will be replaced by server response
      type: type as ChatMessage['type'],
      content,
      isEdited: false,
      createdAt: new Date().toISOString(),
      sender: { id: '', email: '', profile: null },
      tempId,
      clientStatus: 'sending',
    };

    get().addMessage(threadId, optimisticMessage);

    // Send via socket
    socket.emit('chat:send', { threadId, content, type, tempId }, (response: any) => {
      if (!response.success) {
        // Mark as failed
        get().updateMessage(threadId, tempId, { clientStatus: 'failed' });
      }
    });
  },

  markAsRead: (threadId: string) => {
    const { socket, isConnected } = get();
    if (socket && isConnected) {
      socket.emit('chat:mark-read', { threadId });
    }
  },

  startTyping: (threadId: string) => {
    const { socket, isConnected } = get();
    if (socket && isConnected) {
      socket.emit('chat:typing:start', { threadId });
    }
  },

  stopTyping: (threadId: string) => {
    const { socket, isConnected } = get();
    if (socket && isConnected) {
      socket.emit('chat:typing:stop', { threadId });
    }
  },

  joinThread: (threadId: string) => {
    const { socket, isConnected } = get();
    if (socket && isConnected) {
      socket.emit('chat:join', { threadId });
    }
  },

  // Loading states
  setLoadingConversations: (loading: boolean) => set({ isLoadingConversations: loading }),
  setLoadingMessages: (loading: boolean) => set({ isLoadingMessages: loading }),
}));

// Selectors
export const useTypingUsers = (threadId: string) => {
  return useChatStore((state) => Array.from(state.typingUsers.get(threadId) || []));
};

export const useConversationMessages = (threadId: string) => {
  return useChatStore((state) => state.messages.get(threadId) || []);
};

export const useHasMoreMessages = (threadId: string) => {
  return useChatStore((state) => state.hasMoreMessages.get(threadId) ?? true);
};

export const useTotalUnreadCount = () => {
  return useChatStore((state) =>
    state.conversations.reduce((sum, c) => sum + c.unreadCount, 0)
  );
};
```
  </action>
  <verify>
1. TypeScript compiles without errors: `npm run build` in apps/web
2. Store exports useChatStore and selector hooks
3. Socket events are properly typed
  </verify>
  <done>
Chat store created with Socket.IO connection, message handling, typing indicators, delivery/read receipt tracking, and optimistic updates.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useChat hook with auto-connect and API operations</name>
  <files>apps/web/src/hooks/useChat.ts</files>
  <action>
Create useChat hook following usePresence pattern. Hook manages:
- Auto-connect to chat socket on mount
- Fetch conversations from API
- Fetch messages for active conversation
- Expose store actions

```typescript
/**
 * useChat Hook
 *
 * Manages chat connection, conversation fetching, and message loading.
 * Auto-connects to chat WebSocket on mount with valid token.
 */

'use client';

import { useEffect, useCallback, useRef } from 'react';
import { useAuthStore } from '@/store/auth';
import {
  useChatStore,
  Conversation,
  ChatMessage,
} from '@/store/chat';

const API_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001';

interface UseChatOptions {
  autoConnect?: boolean;
}

export function useChat(options: UseChatOptions = {}) {
  const { autoConnect = true } = options;
  const { accessToken, isAuthenticated } = useAuthStore();
  const {
    socket,
    isConnected,
    connectionError,
    conversations,
    activeConversationId,
    isLoadingConversations,
    isLoadingMessages,
    connect,
    disconnect,
    setConversations,
    setActiveConversation,
    addConversation,
    setMessages,
    prependMessages,
    sendMessage,
    markAsRead,
    startTyping,
    stopTyping,
    setLoadingConversations,
    setLoadingMessages,
    joinThread,
  } = useChatStore();

  const hasConnected = useRef(false);

  // Auto-connect on mount
  useEffect(() => {
    if (autoConnect && accessToken && isAuthenticated && !hasConnected.current) {
      hasConnected.current = true;
      connect(accessToken);
    }

    return () => {
      // Don't disconnect on unmount - let store manage lifecycle
    };
  }, [autoConnect, accessToken, isAuthenticated, connect]);

  // Fetch conversations from API
  const fetchConversations = useCallback(async () => {
    if (!accessToken) return;

    setLoadingConversations(true);
    try {
      const response = await fetch(`${API_URL}/chat/threads`, {
        headers: {
          Authorization: `Bearer ${accessToken}`,
        },
      });

      if (!response.ok) {
        throw new Error('Failed to fetch conversations');
      }

      const { data } = await response.json();
      setConversations(data);
    } catch (error) {
      console.error('[useChat] Failed to fetch conversations:', error);
    } finally {
      setLoadingConversations(false);
    }
  }, [accessToken, setConversations, setLoadingConversations]);

  // Fetch messages for a thread
  const fetchMessages = useCallback(
    async (threadId: string, cursor?: string) => {
      if (!accessToken) return;

      setLoadingMessages(true);
      try {
        const params = new URLSearchParams();
        if (cursor) params.set('cursor', cursor);
        params.set('limit', '50');

        const response = await fetch(
          `${API_URL}/chat/threads/${threadId}/messages?${params}`,
          {
            headers: {
              Authorization: `Bearer ${accessToken}`,
            },
          }
        );

        if (!response.ok) {
          throw new Error('Failed to fetch messages');
        }

        const { data } = await response.json();

        if (cursor) {
          // Prepend older messages
          prependMessages(threadId, data.messages, data.hasMore);
        } else {
          // Initial load
          setMessages(threadId, data.messages, data.hasMore);
        }

        return data;
      } catch (error) {
        console.error('[useChat] Failed to fetch messages:', error);
      } finally {
        setLoadingMessages(false);
      }
    },
    [accessToken, setMessages, prependMessages, setLoadingMessages]
  );

  // Load more messages (pagination)
  const loadMoreMessages = useCallback(
    async (threadId: string) => {
      const messages = useChatStore.getState().messages.get(threadId);
      if (!messages || messages.length === 0) return;

      const oldestMessage = messages[0];
      await fetchMessages(threadId, oldestMessage.id);
    },
    [fetchMessages]
  );

  // Create direct message thread
  const createDirectThread = useCallback(
    async (userId: string): Promise<Conversation | null> => {
      if (!accessToken) return null;

      try {
        const response = await fetch(`${API_URL}/chat/threads/direct`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${accessToken}`,
          },
          body: JSON.stringify({ userId }),
        });

        if (!response.ok) {
          throw new Error('Failed to create thread');
        }

        const { data } = await response.json();
        addConversation(data);
        joinThread(data.id);
        return data;
      } catch (error) {
        console.error('[useChat] Failed to create direct thread:', error);
        return null;
      }
    },
    [accessToken, addConversation, joinThread]
  );

  // Create group thread
  const createGroupThread = useCallback(
    async (name: string, memberIds: string[]): Promise<Conversation | null> => {
      if (!accessToken) return null;

      try {
        const response = await fetch(`${API_URL}/chat/threads/group`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${accessToken}`,
          },
          body: JSON.stringify({ name, memberIds }),
        });

        if (!response.ok) {
          throw new Error('Failed to create group thread');
        }

        const { data } = await response.json();
        addConversation(data);
        joinThread(data.id);
        return data;
      } catch (error) {
        console.error('[useChat] Failed to create group thread:', error);
        return null;
      }
    },
    [accessToken, addConversation, joinThread]
  );

  // Search users for new conversation
  const searchUsers = useCallback(
    async (query: string) => {
      if (!accessToken) return [];

      try {
        const response = await fetch(
          `${API_URL}/chat/users/search?q=${encodeURIComponent(query)}`,
          {
            headers: {
              Authorization: `Bearer ${accessToken}`,
            },
          }
        );

        if (!response.ok) {
          throw new Error('Failed to search users');
        }

        const { data } = await response.json();
        return data;
      } catch (error) {
        console.error('[useChat] Failed to search users:', error);
        return [];
      }
    },
    [accessToken]
  );

  // Edit message via REST
  const editMessage = useCallback(
    async (messageId: string, content: string) => {
      if (!accessToken) return null;

      try {
        const response = await fetch(`${API_URL}/chat/messages/${messageId}`, {
          method: 'PATCH',
          headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${accessToken}`,
          },
          body: JSON.stringify({ content }),
        });

        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.message || 'Failed to edit message');
        }

        const { data } = await response.json();
        return data;
      } catch (error) {
        console.error('[useChat] Failed to edit message:', error);
        throw error;
      }
    },
    [accessToken]
  );

  // Delete message via REST
  const deleteMessage = useCallback(
    async (messageId: string) => {
      if (!accessToken) return null;

      try {
        const response = await fetch(`${API_URL}/chat/messages/${messageId}`, {
          method: 'DELETE',
          headers: {
            Authorization: `Bearer ${accessToken}`,
          },
        });

        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.message || 'Failed to delete message');
        }

        const { data } = await response.json();
        return data;
      } catch (error) {
        console.error('[useChat] Failed to delete message:', error);
        throw error;
      }
    },
    [accessToken]
  );

  // Fetch conversations on mount
  useEffect(() => {
    if (isAuthenticated && accessToken) {
      fetchConversations();
    }
  }, [isAuthenticated, accessToken, fetchConversations]);

  // Fetch messages when active conversation changes
  useEffect(() => {
    if (activeConversationId && accessToken) {
      // Check if messages already loaded
      const existingMessages = useChatStore.getState().messages.get(activeConversationId);
      if (!existingMessages || existingMessages.length === 0) {
        fetchMessages(activeConversationId);
      }
    }
  }, [activeConversationId, accessToken, fetchMessages]);

  return {
    // Connection state
    isConnected,
    connectionError,

    // Data
    conversations,
    activeConversationId,
    isLoadingConversations,
    isLoadingMessages,

    // Actions
    connect: () => accessToken && connect(accessToken),
    disconnect,
    setActiveConversation,
    fetchConversations,
    fetchMessages,
    loadMoreMessages,
    sendMessage,
    markAsRead,
    startTyping,
    stopTyping,

    // Thread management
    createDirectThread,
    createGroupThread,
    searchUsers,

    // Message operations
    editMessage,
    deleteMessage,
  };
}

export default useChat;
```
  </action>
  <verify>
1. TypeScript compiles without errors
2. Hook exports all required functions
3. Auto-connect behavior works (connect when authenticated)
  </verify>
  <done>
useChat hook created with auto-connect, conversation/message fetching, pagination support, thread creation, user search, and message edit/delete operations.
  </done>
</task>

<task type="auto">
  <name>Task 3: Export hooks from hooks/index.ts</name>
  <files>apps/web/src/hooks/index.ts</files>
  <action>
Add useChat export to the hooks barrel file:

```typescript
// Add to existing exports
export { useChat } from './useChat';
```

Also export relevant selectors if not already exported from store:
```typescript
export {
  useTypingUsers,
  useConversationMessages,
  useHasMoreMessages,
  useTotalUnreadCount,
} from '@/store/chat';
```
  </action>
  <verify>
`npm run build` in apps/web compiles successfully. Importing `{ useChat }` from `@/hooks` works.
  </verify>
  <done>
useChat and chat selectors exported from hooks barrel file.
  </done>
</task>

</tasks>

<verification>
1. Store: useChatStore connects to /chat namespace with token auth
2. Store: socket.emit('chat:send') sends messages
3. Store: chat:message event updates messages state
4. Store: chat:delivered and chat:read update message statuses
5. Store: Typing indicators work with auto-clear
6. Hook: Auto-connects when authenticated
7. Hook: fetchConversations loads from API
8. Hook: fetchMessages loads with pagination support
9. Hook: createDirectThread and createGroupThread work
10. Hook: searchUsers returns company-filtered results
11. Build: `npm run build` succeeds in apps/web
</verification>

<success_criteria>
- useChatStore connects to /chat WebSocket namespace
- Messages sent via sendMessage emit chat:send and show optimistically
- Incoming chat:message events add to messages state
- chat:delivered and chat:read update clientStatus on messages
- Typing indicators tracked per thread with auto-clear
- useChat hook auto-connects with token
- fetchConversations and fetchMessages load from API
- Thread creation and user search work via REST
- All code compiles without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-chat/06-03-SUMMARY.md`
</output>
