---
phase: 06-chat
plan: 04
type: execute
wave: 4
depends_on: ["06-03"]
files_modified:
  - apps/web/src/components/chat/ConversationList.tsx
  - apps/web/src/components/chat/ConversationItem.tsx
  - apps/web/src/components/chat/MessageThread.tsx
  - apps/web/src/components/chat/MessageBubble.tsx
  - apps/web/src/components/chat/MessageComposer.tsx
  - apps/web/src/components/chat/TypingIndicator.tsx
  - apps/web/src/components/chat/MessageStatus.tsx
  - apps/web/src/components/chat/NewChatModal.tsx
  - apps/web/src/components/chat/index.ts
  - apps/web/src/app/chat/page.tsx
autonomous: false

must_haves:
  truths:
    - "User can see conversation list with unread counts"
    - "User can click conversation to open message thread"
    - "User can type and send messages"
    - "Message bubbles show sent/delivered/read status"
    - "User can start new DM via modal"
  artifacts:
    - path: "apps/web/src/components/chat/ConversationList.tsx"
      provides: "Sidebar with conversation items"
      contains: "ConversationList"
    - path: "apps/web/src/components/chat/MessageThread.tsx"
      provides: "Message display area with scroll"
      contains: "MessageThread"
    - path: "apps/web/src/components/chat/MessageComposer.tsx"
      provides: "Input with typing indicator and send"
      contains: "MessageComposer"
    - path: "apps/web/src/app/chat/page.tsx"
      provides: "Chat page with sidebar + thread layout"
      contains: "export default function ChatPage"
  key_links:
    - from: "apps/web/src/app/chat/page.tsx"
      to: "useChat"
      via: "Hook provides chat state and actions"
      pattern: "useChat\\(\\)"
    - from: "apps/web/src/components/chat/MessageComposer.tsx"
      to: "sendMessage"
      via: "Form submit calls sendMessage"
      pattern: "sendMessage\\("
    - from: "apps/web/src/components/chat/MessageBubble.tsx"
      to: "MessageStatus"
      via: "Shows status icons on own messages"
      pattern: "<MessageStatus"
---

<objective>
Build chat UI components and integrate into a full chat page with conversation sidebar and message thread.

Purpose: Complete the chat user interface per CHAT-01 through CHAT-06 requirements. Users can see conversations, send messages, and track delivery status.

Output: Full chat page with ConversationList, MessageThread, MessageComposer, and supporting components.
</objective>

<execution_context>
@/Users/adityaw/.claude/get-shit-done/workflows/execute-plan.md
@/Users/adityaw/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-chat/06-CONTEXT.md
@.planning/phases/06-chat/06-RESEARCH.md
@.planning/phases/06-chat/06-01-SUMMARY.md
@.planning/phases/06-chat/06-02-SUMMARY.md
@.planning/phases/06-chat/06-03-SUMMARY.md

@apps/web/src/store/chat.ts
@apps/web/src/hooks/useChat.ts
@apps/web/src/components/presence/TeamListCard.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create chat UI components</name>
  <files>
    apps/web/src/components/chat/ConversationList.tsx
    apps/web/src/components/chat/ConversationItem.tsx
    apps/web/src/components/chat/MessageThread.tsx
    apps/web/src/components/chat/MessageBubble.tsx
    apps/web/src/components/chat/MessageComposer.tsx
    apps/web/src/components/chat/TypingIndicator.tsx
    apps/web/src/components/chat/MessageStatus.tsx
    apps/web/src/components/chat/NewChatModal.tsx
    apps/web/src/components/chat/index.ts
  </files>
  <action>
Create the chat components directory and all UI components. Follow existing component patterns (shadcn/ui, Tailwind, lucide-react icons).

**1. MessageStatus.tsx** - Checkmarks for sent/delivered/read:
```typescript
'use client';

import { Check, CheckCheck, Clock } from 'lucide-react';
import { cn } from '@/lib/utils';
import { MessageStatus as Status } from '@/store/chat';

interface MessageStatusProps {
  status?: Status;
  className?: string;
}

export function MessageStatus({ status, className }: MessageStatusProps) {
  if (!status || status === 'sending') {
    return <Clock className={cn('h-3.5 w-3.5 text-muted-foreground', className)} />;
  }

  if (status === 'failed') {
    return <span className={cn('text-xs text-destructive', className)}>Failed</span>;
  }

  if (status === 'sent') {
    return <Check className={cn('h-3.5 w-3.5 text-muted-foreground', className)} />;
  }

  if (status === 'delivered') {
    return <CheckCheck className={cn('h-3.5 w-3.5 text-muted-foreground', className)} />;
  }

  // read
  return <CheckCheck className={cn('h-3.5 w-3.5 text-primary', className)} />;
}
```

**2. TypingIndicator.tsx** - Shows who is typing:
```typescript
'use client';

import { useChatStore, Conversation } from '@/store/chat';

interface TypingIndicatorProps {
  threadId: string;
  members: Conversation['members'];
}

export function TypingIndicator({ threadId, members }: TypingIndicatorProps) {
  const typingUserIds = useChatStore((state) =>
    Array.from(state.typingUsers.get(threadId) || [])
  );

  if (typingUserIds.length === 0) return null;

  const typingNames = typingUserIds
    .map((userId) => {
      const member = members.find((m) => m.userId === userId);
      return member?.user.profile?.firstName || 'Someone';
    })
    .slice(0, 3);

  const text =
    typingNames.length === 1
      ? `${typingNames[0]} is typing...`
      : typingNames.length === 2
      ? `${typingNames[0]} and ${typingNames[1]} are typing...`
      : `${typingNames[0]} and ${typingNames.length - 1} others are typing...`;

  return (
    <div className="flex items-center gap-2 px-4 py-1 text-sm text-muted-foreground">
      <div className="flex gap-1">
        <span className="animate-bounce" style={{ animationDelay: '0ms' }}>.</span>
        <span className="animate-bounce" style={{ animationDelay: '150ms' }}>.</span>
        <span className="animate-bounce" style={{ animationDelay: '300ms' }}>.</span>
      </div>
      <span>{text}</span>
    </div>
  );
}
```

**3. MessageBubble.tsx** - Individual message display:
```typescript
'use client';

import { format, formatRelative } from 'date-fns';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import { cn } from '@/lib/utils';
import { ChatMessage } from '@/store/chat';
import { MessageStatus } from './MessageStatus';
import { useAuthStore } from '@/store/auth';

interface MessageBubbleProps {
  message: ChatMessage;
  showAvatar?: boolean;
  isGrouped?: boolean;
}

export function MessageBubble({ message, showAvatar = true, isGrouped = false }: MessageBubbleProps) {
  const currentUserId = useAuthStore((state) => state.user?.id);
  const isOwn = message.senderId === currentUserId;
  const isDeleted = !!message.deletedAt;

  const senderName = message.sender?.profile
    ? `${message.sender.profile.firstName} ${message.sender.profile.lastName}`
    : message.sender?.email || 'Unknown';

  const initials = message.sender?.profile
    ? `${message.sender.profile.firstName?.[0] || ''}${message.sender.profile.lastName?.[0] || ''}`
    : '?';

  const formatTime = (dateStr: string) => {
    const date = new Date(dateStr);
    const now = new Date();
    const diffDays = Math.floor((now.getTime() - date.getTime()) / (1000 * 60 * 60 * 24));

    if (diffDays === 0) {
      return format(date, 'HH:mm');
    } else if (diffDays < 7) {
      return formatRelative(date, now);
    } else {
      return format(date, 'MMM d, HH:mm');
    }
  };

  return (
    <div
      className={cn(
        'flex gap-2 px-4',
        isOwn ? 'flex-row-reverse' : 'flex-row',
        isGrouped ? 'mt-0.5' : 'mt-3'
      )}
    >
      {/* Avatar */}
      <div className="w-8 flex-shrink-0">
        {showAvatar && !isOwn && (
          <Avatar className="h-8 w-8">
            <AvatarImage src={message.sender?.profile?.avatarUrl} />
            <AvatarFallback className="text-xs">{initials}</AvatarFallback>
          </Avatar>
        )}
      </div>

      {/* Message content */}
      <div className={cn('flex flex-col max-w-[70%]', isOwn ? 'items-end' : 'items-start')}>
        {/* Sender name (for group chats, not own messages) */}
        {!isOwn && !isGrouped && (
          <span className="text-xs text-muted-foreground mb-0.5 ml-1">{senderName}</span>
        )}

        {/* Bubble */}
        <div
          className={cn(
            'rounded-2xl px-4 py-2',
            isOwn
              ? 'bg-primary text-primary-foreground rounded-br-md'
              : 'bg-muted rounded-bl-md',
            isDeleted && 'italic opacity-60'
          )}
        >
          {isDeleted ? (
            <span className="text-sm">This message was deleted</span>
          ) : (
            <p className="text-sm whitespace-pre-wrap break-words">{message.content}</p>
          )}
        </div>

        {/* Meta: time, edited, status */}
        <div className="flex items-center gap-1 mt-0.5 px-1">
          <span className="text-xs text-muted-foreground">{formatTime(message.createdAt)}</span>
          {message.isEdited && (
            <span className="text-xs text-muted-foreground">(edited)</span>
          )}
          {isOwn && !isDeleted && <MessageStatus status={message.clientStatus} />}
        </div>
      </div>
    </div>
  );
}
```

**4. MessageThread.tsx** - Message list with scroll:
```typescript
'use client';

import { useRef, useEffect, useCallback } from 'react';
import { useChatStore, ChatMessage, Conversation } from '@/store/chat';
import { useChat } from '@/hooks';
import { MessageBubble } from './MessageBubble';
import { TypingIndicator } from './TypingIndicator';
import { Loader2 } from 'lucide-react';
import { Button } from '@/components/ui/button';

interface MessageThreadProps {
  conversation: Conversation;
}

export function MessageThread({ conversation }: MessageThreadProps) {
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  const { loadMoreMessages, isLoadingMessages } = useChat({ autoConnect: false });

  const messages = useChatStore((state) => state.messages.get(conversation.id) || []);
  const hasMore = useChatStore((state) => state.hasMoreMessages.get(conversation.id) ?? true);

  // Scroll to bottom on new messages
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages.length]);

  // Group consecutive messages from same sender
  const groupedMessages = messages.reduce<{ message: ChatMessage; isGrouped: boolean; showAvatar: boolean }[]>(
    (acc, msg, index) => {
      const prevMsg = messages[index - 1];
      const isGrouped = prevMsg && prevMsg.senderId === msg.senderId;
      const nextMsg = messages[index + 1];
      const showAvatar = !nextMsg || nextMsg.senderId !== msg.senderId;

      acc.push({ message: msg, isGrouped, showAvatar });
      return acc;
    },
    []
  );

  const handleLoadMore = useCallback(() => {
    if (!isLoadingMessages && hasMore) {
      loadMoreMessages(conversation.id);
    }
  }, [conversation.id, loadMoreMessages, isLoadingMessages, hasMore]);

  return (
    <div
      ref={containerRef}
      className="flex-1 overflow-y-auto flex flex-col"
    >
      {/* Load more button */}
      {hasMore && (
        <div className="flex justify-center py-4">
          <Button
            variant="ghost"
            size="sm"
            onClick={handleLoadMore}
            disabled={isLoadingMessages}
          >
            {isLoadingMessages ? (
              <Loader2 className="h-4 w-4 animate-spin mr-2" />
            ) : null}
            Load older messages
          </Button>
        </div>
      )}

      {/* Messages */}
      <div className="flex-1">
        {groupedMessages.map(({ message, isGrouped, showAvatar }) => (
          <MessageBubble
            key={message.id}
            message={message}
            showAvatar={showAvatar}
            isGrouped={isGrouped}
          />
        ))}
      </div>

      {/* Typing indicator */}
      <TypingIndicator threadId={conversation.id} members={conversation.members} />

      {/* Scroll anchor */}
      <div ref={messagesEndRef} />
    </div>
  );
}
```

**5. MessageComposer.tsx** - Input with typing indicator:
```typescript
'use client';

import { useState, useRef, useCallback, useEffect, FormEvent } from 'react';
import { Send } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { useChat } from '@/hooks';

interface MessageComposerProps {
  threadId: string;
}

export function MessageComposer({ threadId }: MessageComposerProps) {
  const [content, setContent] = useState('');
  const [isSending, setIsSending] = useState(false);
  const typingTimeoutRef = useRef<NodeJS.Timeout>();
  const { sendMessage, startTyping, stopTyping } = useChat({ autoConnect: false });

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setContent(e.target.value);

    // Typing indicator
    startTyping(threadId);

    // Clear existing timeout
    if (typingTimeoutRef.current) {
      clearTimeout(typingTimeoutRef.current);
    }

    // Stop typing after 2 seconds of inactivity
    typingTimeoutRef.current = setTimeout(() => {
      stopTyping(threadId);
    }, 2000);
  };

  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault();
    const trimmed = content.trim();
    if (!trimmed || isSending) return;

    setIsSending(true);
    try {
      await sendMessage(threadId, trimmed);
      setContent('');
      stopTyping(threadId);
    } catch (error) {
      console.error('Failed to send message:', error);
    } finally {
      setIsSending(false);
    }
  };

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      if (typingTimeoutRef.current) {
        clearTimeout(typingTimeoutRef.current);
      }
      stopTyping(threadId);
    };
  }, [threadId, stopTyping]);

  return (
    <form onSubmit={handleSubmit} className="p-4 border-t">
      <div className="flex gap-2">
        <Input
          value={content}
          onChange={handleChange}
          placeholder="Type a message..."
          className="flex-1"
          disabled={isSending}
        />
        <Button type="submit" size="icon" disabled={!content.trim() || isSending}>
          <Send className="h-4 w-4" />
        </Button>
      </div>
    </form>
  );
}
```

**6. ConversationItem.tsx** - Single conversation row:
```typescript
'use client';

import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import { Badge } from '@/components/ui/badge';
import { cn } from '@/lib/utils';
import { Conversation } from '@/store/chat';
import { useAuthStore } from '@/store/auth';
import { formatRelative } from 'date-fns';

interface ConversationItemProps {
  conversation: Conversation;
  isActive: boolean;
  onClick: () => void;
}

export function ConversationItem({ conversation, isActive, onClick }: ConversationItemProps) {
  const currentUserId = useAuthStore((state) => state.user?.id);

  // For direct chats, show the other person's info
  const otherMember = conversation.type === 'Direct'
    ? conversation.members.find((m) => m.userId !== currentUserId)
    : null;

  const displayName = conversation.name
    || (otherMember?.user.profile
      ? `${otherMember.user.profile.firstName} ${otherMember.user.profile.lastName}`
      : otherMember?.user.email)
    || 'Unknown';

  const initials = otherMember?.user.profile
    ? `${otherMember.user.profile.firstName?.[0] || ''}${otherMember.user.profile.lastName?.[0] || ''}`
    : conversation.name?.[0]?.toUpperCase() || '?';

  const avatarUrl = otherMember?.user.profile?.avatarUrl;

  const lastMessage = conversation.messages?.[0];
  const lastMessagePreview = lastMessage?.deletedAt
    ? 'Message deleted'
    : lastMessage?.content
    ? lastMessage.content.length > 40
      ? lastMessage.content.slice(0, 40) + '...'
      : lastMessage.content
    : 'No messages yet';

  const lastMessageTime = conversation.lastMessageAt
    ? formatRelative(new Date(conversation.lastMessageAt), new Date())
    : '';

  return (
    <button
      onClick={onClick}
      className={cn(
        'w-full flex items-center gap-3 p-3 rounded-lg text-left transition-colors',
        isActive
          ? 'bg-primary/10 border border-primary/20'
          : 'hover:bg-muted/50'
      )}
    >
      <Avatar className="h-10 w-10">
        <AvatarImage src={avatarUrl} />
        <AvatarFallback>{initials}</AvatarFallback>
      </Avatar>

      <div className="flex-1 min-w-0">
        <div className="flex items-center justify-between gap-2">
          <span className="font-medium truncate">{displayName}</span>
          {conversation.unreadCount > 0 && (
            <Badge variant="default" className="h-5 min-w-5 flex items-center justify-center">
              {conversation.unreadCount > 99 ? '99+' : conversation.unreadCount}
            </Badge>
          )}
        </div>
        <div className="flex items-center justify-between gap-2">
          <span className="text-sm text-muted-foreground truncate">{lastMessagePreview}</span>
          <span className="text-xs text-muted-foreground flex-shrink-0">{lastMessageTime}</span>
        </div>
      </div>
    </button>
  );
}
```

**7. ConversationList.tsx** - Sidebar with conversations:
```typescript
'use client';

import { useState } from 'react';
import { Plus, MessageSquare, Loader2 } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { ScrollArea } from '@/components/ui/scroll-area';
import { useChatStore } from '@/store/chat';
import { useChat } from '@/hooks';
import { ConversationItem } from './ConversationItem';
import { NewChatModal } from './NewChatModal';

export function ConversationList() {
  const [searchQuery, setSearchQuery] = useState('');
  const [showNewChat, setShowNewChat] = useState(false);

  const { conversations, isLoadingConversations, setActiveConversation, activeConversationId } = useChat({
    autoConnect: false,
  });

  const filteredConversations = conversations.filter((c) => {
    if (!searchQuery) return true;
    const query = searchQuery.toLowerCase();

    // Search by name
    if (c.name?.toLowerCase().includes(query)) return true;

    // Search by member names/emails
    return c.members.some(
      (m) =>
        m.user.email.toLowerCase().includes(query) ||
        m.user.profile?.firstName?.toLowerCase().includes(query) ||
        m.user.profile?.lastName?.toLowerCase().includes(query)
    );
  });

  return (
    <div className="flex flex-col h-full border-r">
      {/* Header */}
      <div className="p-4 border-b">
        <div className="flex items-center justify-between mb-3">
          <h2 className="font-semibold text-lg flex items-center gap-2">
            <MessageSquare className="h-5 w-5" />
            Messages
          </h2>
          <Button size="icon" variant="ghost" onClick={() => setShowNewChat(true)}>
            <Plus className="h-4 w-4" />
          </Button>
        </div>
        <Input
          placeholder="Search conversations..."
          value={searchQuery}
          onChange={(e) => setSearchQuery(e.target.value)}
          className="h-9"
        />
      </div>

      {/* Conversation list */}
      <ScrollArea className="flex-1">
        <div className="p-2">
          {isLoadingConversations ? (
            <div className="flex items-center justify-center py-8">
              <Loader2 className="h-6 w-6 animate-spin text-muted-foreground" />
            </div>
          ) : filteredConversations.length === 0 ? (
            <div className="text-center py-8 text-muted-foreground">
              {searchQuery ? 'No conversations found' : 'No conversations yet'}
            </div>
          ) : (
            filteredConversations.map((conversation) => (
              <ConversationItem
                key={conversation.id}
                conversation={conversation}
                isActive={conversation.id === activeConversationId}
                onClick={() => setActiveConversation(conversation.id)}
              />
            ))
          )}
        </div>
      </ScrollArea>

      {/* New chat modal */}
      <NewChatModal open={showNewChat} onOpenChange={setShowNewChat} />
    </div>
  );
}
```

**8. NewChatModal.tsx** - Start new conversation:
```typescript
'use client';

import { useState, useCallback } from 'react';
import { Search, Loader2, User, Users } from 'lucide-react';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import { Input } from '@/components/ui/input';
import { Button } from '@/components/ui/button';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Checkbox } from '@/components/ui/checkbox';
import { Label } from '@/components/ui/label';
import { useChat } from '@/hooks';
import { useDebounce } from '@/hooks/useDebounce';
import { useEffect } from 'react';

interface User {
  id: string;
  email: string;
  profile?: {
    firstName: string;
    lastName: string;
    avatarUrl?: string;
  } | null;
}

interface NewChatModalProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
}

export function NewChatModal({ open, onOpenChange }: NewChatModalProps) {
  const [searchQuery, setSearchQuery] = useState('');
  const [searchResults, setSearchResults] = useState<User[]>([]);
  const [isSearching, setIsSearching] = useState(false);
  const [selectedUsers, setSelectedUsers] = useState<User[]>([]);
  const [groupName, setGroupName] = useState('');
  const [isCreating, setIsCreating] = useState(false);
  const [tab, setTab] = useState<'direct' | 'group'>('direct');

  const { searchUsers, createDirectThread, createGroupThread, setActiveConversation } = useChat({
    autoConnect: false,
  });

  const debouncedQuery = useDebounce(searchQuery, 300);

  // Search users when query changes
  useEffect(() => {
    if (debouncedQuery.length >= 2) {
      setIsSearching(true);
      searchUsers(debouncedQuery)
        .then(setSearchResults)
        .finally(() => setIsSearching(false));
    } else {
      setSearchResults([]);
    }
  }, [debouncedQuery, searchUsers]);

  const handleSelectUser = useCallback((user: User) => {
    if (tab === 'direct') {
      // Start DM immediately
      setIsCreating(true);
      createDirectThread(user.id).then((thread) => {
        if (thread) {
          setActiveConversation(thread.id);
          onOpenChange(false);
          resetState();
        }
        setIsCreating(false);
      });
    } else {
      // Toggle selection for group
      setSelectedUsers((prev) => {
        const exists = prev.find((u) => u.id === user.id);
        if (exists) {
          return prev.filter((u) => u.id !== user.id);
        }
        return [...prev, user];
      });
    }
  }, [tab, createDirectThread, setActiveConversation, onOpenChange]);

  const handleCreateGroup = async () => {
    if (!groupName.trim() || selectedUsers.length < 1) return;

    setIsCreating(true);
    const thread = await createGroupThread(
      groupName.trim(),
      selectedUsers.map((u) => u.id)
    );

    if (thread) {
      setActiveConversation(thread.id);
      onOpenChange(false);
      resetState();
    }
    setIsCreating(false);
  };

  const resetState = () => {
    setSearchQuery('');
    setSearchResults([]);
    setSelectedUsers([]);
    setGroupName('');
  };

  const getUserDisplayName = (user: User) =>
    user.profile ? `${user.profile.firstName} ${user.profile.lastName}` : user.email;

  const getUserInitials = (user: User) =>
    user.profile
      ? `${user.profile.firstName?.[0] || ''}${user.profile.lastName?.[0] || ''}`
      : user.email[0].toUpperCase();

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-md">
        <DialogHeader>
          <DialogTitle>New Conversation</DialogTitle>
        </DialogHeader>

        <Tabs value={tab} onValueChange={(v) => setTab(v as 'direct' | 'group')}>
          <TabsList className="grid w-full grid-cols-2">
            <TabsTrigger value="direct">
              <User className="h-4 w-4 mr-2" />
              Direct Message
            </TabsTrigger>
            <TabsTrigger value="group">
              <Users className="h-4 w-4 mr-2" />
              Group Chat
            </TabsTrigger>
          </TabsList>

          <div className="mt-4">
            {/* Search input */}
            <div className="relative">
              <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
              <Input
                placeholder="Search people..."
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                className="pl-9"
              />
            </div>

            {/* Group name input (only for group tab) */}
            {tab === 'group' && (
              <div className="mt-3">
                <Label htmlFor="groupName">Group Name</Label>
                <Input
                  id="groupName"
                  placeholder="Enter group name..."
                  value={groupName}
                  onChange={(e) => setGroupName(e.target.value)}
                  className="mt-1"
                />
              </div>
            )}

            {/* Selected users (only for group tab) */}
            {tab === 'group' && selectedUsers.length > 0 && (
              <div className="mt-3 flex flex-wrap gap-2">
                {selectedUsers.map((user) => (
                  <div
                    key={user.id}
                    className="flex items-center gap-1 bg-primary/10 text-primary px-2 py-1 rounded-full text-sm"
                  >
                    <span>{getUserDisplayName(user)}</span>
                    <button
                      onClick={() => handleSelectUser(user)}
                      className="hover:text-destructive"
                    >
                      &times;
                    </button>
                  </div>
                ))}
              </div>
            )}

            {/* Search results */}
            <div className="mt-3 max-h-[200px] overflow-y-auto">
              {isSearching ? (
                <div className="flex justify-center py-4">
                  <Loader2 className="h-5 w-5 animate-spin text-muted-foreground" />
                </div>
              ) : searchResults.length === 0 && searchQuery.length >= 2 ? (
                <p className="text-center py-4 text-muted-foreground">No users found</p>
              ) : (
                searchResults.map((user) => {
                  const isSelected = selectedUsers.some((u) => u.id === user.id);
                  return (
                    <button
                      key={user.id}
                      onClick={() => handleSelectUser(user)}
                      disabled={isCreating}
                      className="w-full flex items-center gap-3 p-2 rounded-lg hover:bg-muted/50 transition-colors"
                    >
                      {tab === 'group' && (
                        <Checkbox checked={isSelected} className="mr-1" />
                      )}
                      <Avatar className="h-8 w-8">
                        <AvatarImage src={user.profile?.avatarUrl} />
                        <AvatarFallback>{getUserInitials(user)}</AvatarFallback>
                      </Avatar>
                      <div className="text-left">
                        <p className="font-medium">{getUserDisplayName(user)}</p>
                        <p className="text-xs text-muted-foreground">{user.email}</p>
                      </div>
                    </button>
                  );
                })
              )}
            </div>

            {/* Create group button */}
            {tab === 'group' && (
              <Button
                onClick={handleCreateGroup}
                disabled={!groupName.trim() || selectedUsers.length < 1 || isCreating}
                className="w-full mt-4"
              >
                {isCreating ? (
                  <Loader2 className="h-4 w-4 animate-spin mr-2" />
                ) : null}
                Create Group ({selectedUsers.length} members)
              </Button>
            )}
          </div>
        </Tabs>
      </DialogContent>
    </Dialog>
  );
}
```

**9. index.ts** - Barrel export:
```typescript
export { ConversationList } from './ConversationList';
export { ConversationItem } from './ConversationItem';
export { MessageThread } from './MessageThread';
export { MessageBubble } from './MessageBubble';
export { MessageComposer } from './MessageComposer';
export { TypingIndicator } from './TypingIndicator';
export { MessageStatus } from './MessageStatus';
export { NewChatModal } from './NewChatModal';
```

**Note:** If useDebounce hook doesn't exist, create it at `apps/web/src/hooks/useDebounce.ts`:
```typescript
import { useState, useEffect } from 'react';

export function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}
```
And add export to hooks/index.ts: `export { useDebounce } from './useDebounce';`
  </action>
  <verify>
1. All component files created in apps/web/src/components/chat/
2. TypeScript compiles without errors: `npm run build`
3. Components import properly from index barrel
  </verify>
  <done>
Chat UI components created: MessageStatus, TypingIndicator, MessageBubble, MessageThread, MessageComposer, ConversationItem, ConversationList, NewChatModal, and barrel export.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create chat page with full layout</name>
  <files>apps/web/src/app/chat/page.tsx</files>
  <action>
Create the chat page with sidebar + message thread layout:

```typescript
'use client';

import { useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { MessageSquare, Wifi, WifiOff } from 'lucide-react';
import { useAuthStore } from '@/store/auth';
import { useChatStore } from '@/store/chat';
import { useChat } from '@/hooks';
import { ConversationList, MessageThread, MessageComposer } from '@/components/chat';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';

export default function ChatPage() {
  const router = useRouter();
  const { isAuthenticated, isLoading: authLoading } = useAuthStore();
  const { isConnected, connectionError } = useChat();

  const activeConversationId = useChatStore((state) => state.activeConversationId);
  const conversations = useChatStore((state) => state.conversations);

  const activeConversation = conversations.find((c) => c.id === activeConversationId);

  // Redirect if not authenticated
  useEffect(() => {
    if (!authLoading && !isAuthenticated) {
      router.push('/login');
    }
  }, [authLoading, isAuthenticated, router]);

  if (authLoading) {
    return (
      <div className="flex items-center justify-center h-[calc(100vh-4rem)]">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary" />
      </div>
    );
  }

  // Get display name for header
  const getHeaderTitle = () => {
    if (!activeConversation) return 'Chat';

    if (activeConversation.name) return activeConversation.name;

    if (activeConversation.type === 'Direct') {
      const currentUserId = useAuthStore.getState().user?.id;
      const other = activeConversation.members.find((m) => m.userId !== currentUserId);
      if (other?.user.profile) {
        return `${other.user.profile.firstName} ${other.user.profile.lastName}`;
      }
      return other?.user.email || 'Direct Message';
    }

    return 'Group Chat';
  };

  return (
    <div className="h-[calc(100vh-4rem)] flex">
      {/* Sidebar - Conversation List */}
      <div className="w-80 flex-shrink-0">
        <ConversationList />
      </div>

      {/* Main area - Message Thread */}
      <div className="flex-1 flex flex-col">
        {activeConversation ? (
          <>
            {/* Header */}
            <div className="p-4 border-b flex items-center justify-between">
              <div className="flex items-center gap-3">
                <h2 className="font-semibold">{getHeaderTitle()}</h2>
                {activeConversation.type !== 'Direct' && (
                  <span className="text-sm text-muted-foreground">
                    {activeConversation.members.length} members
                  </span>
                )}
              </div>
              <Badge variant={isConnected ? 'default' : 'destructive'} className="gap-1">
                {isConnected ? (
                  <>
                    <Wifi className="h-3 w-3" />
                    Connected
                  </>
                ) : (
                  <>
                    <WifiOff className="h-3 w-3" />
                    {connectionError || 'Disconnected'}
                  </>
                )}
              </Badge>
            </div>

            {/* Messages */}
            <MessageThread conversation={activeConversation} />

            {/* Composer */}
            <MessageComposer threadId={activeConversation.id} />
          </>
        ) : (
          // No conversation selected
          <div className="flex-1 flex items-center justify-center">
            <Card className="max-w-md">
              <CardHeader className="text-center">
                <CardTitle className="flex items-center justify-center gap-2">
                  <MessageSquare className="h-6 w-6" />
                  Welcome to Chat
                </CardTitle>
              </CardHeader>
              <CardContent className="text-center text-muted-foreground">
                <p>Select a conversation from the sidebar or start a new one.</p>
                <div className="mt-4 flex items-center justify-center gap-2">
                  <Badge variant={isConnected ? 'default' : 'secondary'}>
                    {isConnected ? 'Connected' : 'Connecting...'}
                  </Badge>
                </div>
              </CardContent>
            </Card>
          </div>
        )}
      </div>
    </div>
  );
}
```

Also, add chat to the navigation. Check if there's a navigation component and add a link to /chat with a message icon and unread badge.
  </action>
  <verify>
1. Navigate to /chat - page loads
2. Conversation list shows in sidebar
3. Clicking conversation shows messages
4. Can type and send message
5. Messages appear in real-time
  </verify>
  <done>
Chat page created with sidebar layout, conversation list, message thread, and composer. Connection status shown in header.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete chat interface with:
- Conversation list sidebar with unread badges
- Message thread with bubbles (own vs others)
- Message composer with typing indicator
- New chat modal for DMs and groups
- Real-time message delivery via WebSocket
- Sent/delivered/read status checkmarks
  </what-built>
  <how-to-verify>
1. Ensure API is running: `cd apps/api && npm run start:dev`
2. Ensure web is running: `cd apps/web && npm run dev`
3. Log in with two different users in two browser windows

**Test 1: Start DM**
- User A: Go to /chat, click + button
- Search for User B's name
- Click to start conversation

**Test 2: Send Message**
- User A: Type "Hello from A" and send
- Verify: Message appears immediately with single checkmark (sent)
- User B: Should see message appear in real-time
- User A: Checkmark should become double (delivered) then blue (read when B opens)

**Test 3: Typing Indicator**
- User B: Start typing but don't send
- User A: Should see "User B is typing..."

**Test 4: Group Chat**
- User A: Click +, switch to "Group Chat" tab
- Enter group name, select User B (and optionally others)
- Create group
- Send a message

**Test 5: Unread Count**
- User B: Navigate away from chat
- User A: Send another message
- User B: Check sidebar - should show unread badge (1)

6. Verify UI: Messages have proper styling, timestamps show correctly
  </how-to-verify>
  <resume-signal>Type "approved" if chat works correctly, or describe any issues found.</resume-signal>
</task>

</tasks>

<verification>
1. Components: All chat components exist and export correctly
2. Page: /chat loads with sidebar + main area layout
3. Connection: WebSocket connects and shows status
4. Conversations: List shows with unread counts
5. Messages: Send and receive in real-time
6. Status: Checkmarks show sent -> delivered -> read progression
7. Typing: Indicator shows when others are typing
8. New Chat: Can start DM and group conversations
9. Build: `npm run build` succeeds in apps/web
</verification>

<success_criteria>
- User can see conversation list with unread counts
- User can click conversation to view messages
- User can type and send messages
- Messages appear instantly (< 500ms) via WebSocket
- Message bubbles show sent/delivered/read checkmarks
- Typing indicator shows when others type
- User can start new DM via modal
- User can create group chat via modal
- Human verification confirms chat works end-to-end
</success_criteria>

<output>
After completion, create `.planning/phases/06-chat/06-04-SUMMARY.md`
</output>
