---
phase: 06-chat
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/prisma/schema.prisma
  - apps/api/src/chat/chat.service.ts
  - apps/api/src/chat/chat.controller.ts
  - apps/api/src/chat/dto/index.ts
autonomous: true

must_haves:
  truths:
    - "Messages can be soft-deleted (show 'message deleted')"
    - "Messages can be edited within 15-minute window"
    - "Message status tracks sent/delivered/read per recipient"
    - "User search returns same-company users only"
  artifacts:
    - path: "apps/api/prisma/schema.prisma"
      provides: "MessageStatus model with deliveredAt/readAt"
      contains: "model MessageStatus"
    - path: "apps/api/src/chat/chat.service.ts"
      provides: "Edit/delete methods, status tracking, company validation"
      exports: ["editMessage", "deleteMessage", "markDelivered"]
    - path: "apps/api/src/chat/dto/index.ts"
      provides: "Validated DTOs for chat operations"
      exports: ["CreateMessageDto", "EditMessageDto", "CreateThreadDto"]
  key_links:
    - from: "apps/api/src/chat/chat.service.ts"
      to: "prisma.messageStatus"
      via: "Create status on message send, update on delivery/read"
      pattern: "prisma\\.messageStatus\\.(create|update)"
    - from: "apps/api/src/chat/chat.controller.ts"
      to: "/chat/users/search"
      via: "User search endpoint with company filter"
      pattern: "@Get\\('users/search'\\)"
---

<objective>
Extend chat schema and API with message status tracking, edit/delete capability, and company-scoped user search.

Purpose: Enable delivery/read receipts (checkmarks) and message editing/deletion per CHAT-05 requirement. Add user search for starting new conversations.

Output: Extended Prisma schema, enhanced ChatService with status tracking and edit/delete, validated DTOs, user search endpoint.
</objective>

<execution_context>
@/Users/adityaw/.claude/get-shit-done/workflows/execute-plan.md
@/Users/adityaw/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-chat/06-CONTEXT.md
@.planning/phases/06-chat/06-RESEARCH.md

@apps/api/prisma/schema.prisma
@apps/api/src/chat/chat.service.ts
@apps/api/src/chat/chat.controller.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend Prisma schema with MessageStatus model</name>
  <files>apps/api/prisma/schema.prisma</files>
  <action>
Add MessageStatus model for per-recipient delivery/read tracking:

```prisma
/// Per-recipient message status for delivery/read tracking
model MessageStatus {
  id          String    @id @default(uuid())
  messageId   String
  userId      String    // Recipient user
  deliveredAt DateTime?
  readAt      DateTime?
  createdAt   DateTime  @default(now())

  message ChatMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user    User        @relation("MessageRecipient", fields: [userId], references: [id])

  @@unique([messageId, userId])
  @@index([userId])
  @@map("message_statuses")
}
```

Modify ChatMessage model:
1. Add `deletedAt DateTime?` field for soft delete
2. Add `statuses MessageStatus[]` relation

Modify User model:
1. Add `messageStatuses MessageStatus[] @relation("MessageRecipient")` relation

Run `npx prisma db push` to apply schema changes.
  </action>
  <verify>
Run `npx prisma db push` succeeds. Query `SELECT column_name FROM information_schema.columns WHERE table_name = 'message_statuses'` shows id, messageId, userId, deliveredAt, readAt, createdAt columns.
  </verify>
  <done>
MessageStatus model exists in schema. ChatMessage has deletedAt field and statuses relation. Database schema updated.
  </done>
</task>

<task type="auto">
  <name>Task 2: Enhance ChatService with status tracking and edit/delete</name>
  <files>
    apps/api/src/chat/chat.service.ts
    apps/api/src/chat/chat.controller.ts
    apps/api/src/chat/dto/index.ts
  </files>
  <action>
**Create DTOs file** at `apps/api/src/chat/dto/index.ts`:

```typescript
import { IsString, IsOptional, IsArray, IsUUID, MaxLength, IsEnum } from 'class-validator';
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { ChatMessageType } from '@prisma/client';

export class CreateMessageDto {
  @ApiProperty({ enum: ChatMessageType })
  @IsEnum(ChatMessageType)
  type: ChatMessageType;

  @ApiPropertyOptional()
  @IsOptional()
  @IsString()
  @MaxLength(4000)
  content?: string;

  @ApiPropertyOptional()
  @IsOptional()
  @IsString()
  attachmentUrl?: string;

  @ApiPropertyOptional()
  @IsOptional()
  @IsString()
  attachmentType?: string;

  @ApiPropertyOptional({ description: 'Client-generated ID for idempotency' })
  @IsOptional()
  @IsString()
  tempId?: string;
}

export class EditMessageDto {
  @ApiProperty()
  @IsString()
  @MaxLength(4000)
  content: string;
}

export class CreateDirectThreadDto {
  @ApiProperty()
  @IsUUID()
  userId: string;
}

export class CreateGroupThreadDto {
  @ApiProperty()
  @IsString()
  @MaxLength(100)
  name: string;

  @ApiProperty({ type: [String] })
  @IsArray()
  @IsUUID('4', { each: true })
  memberIds: string[];

  @ApiPropertyOptional()
  @IsOptional()
  @IsUUID()
  projectId?: string;
}
```

**Enhance ChatService** (`chat.service.ts`):

1. Add company validation to `createDirectThread`:
```typescript
async createDirectThread(userId: string, otherUserId: string) {
  // Validate same company
  const [user, other] = await Promise.all([
    this.prisma.user.findUnique({ where: { id: userId }, select: { companyId: true } }),
    this.prisma.user.findUnique({ where: { id: otherUserId }, select: { companyId: true } }),
  ]);

  if (!user || !other) {
    throw new NotFoundException('User not found');
  }

  if (user.companyId !== other.companyId) {
    throw new BadRequestException('Cannot message users from different companies');
  }
  // ... rest of existing logic
}
```

2. Similarly validate company in `createGroupThread`

3. Modify `sendMessage` to create MessageStatus for each recipient:
```typescript
async sendMessage(userId: string, threadId: string, data: CreateMessageDto) {
  // ... existing validation and message creation ...

  // Create message status for all other members
  const members = await this.prisma.chatMember.findMany({
    where: { threadId, userId: { not: userId } },
    select: { userId: true },
  });

  if (members.length > 0) {
    await this.prisma.messageStatus.createMany({
      data: members.map((m) => ({
        messageId: message.id,
        userId: m.userId,
      })),
    });
  }

  return message;
}
```

4. Add `markDelivered` method:
```typescript
async markDelivered(messageIds: string[], userId: string) {
  await this.prisma.messageStatus.updateMany({
    where: {
      messageId: { in: messageIds },
      userId,
      deliveredAt: null,
    },
    data: { deliveredAt: new Date() },
  });
}
```

5. Modify `markRead` to update MessageStatus:
```typescript
async markRead(userId: string, threadId: string) {
  // Update unread count
  await this.prisma.chatMember.update({
    where: { threadId_userId: { threadId, userId } },
    data: { lastReadAt: new Date(), unreadCount: 0 },
  });

  // Update message statuses
  const unreadMessages = await this.prisma.chatMessage.findMany({
    where: {
      threadId,
      senderId: { not: userId },
      statuses: { some: { userId, readAt: null } },
    },
    select: { id: true },
  });

  if (unreadMessages.length > 0) {
    await this.prisma.messageStatus.updateMany({
      where: {
        messageId: { in: unreadMessages.map((m) => m.id) },
        userId,
        readAt: null,
      },
      data: { readAt: new Date(), deliveredAt: new Date() },
    });
  }

  return unreadMessages.map((m) => m.id);
}
```

6. Add `editMessage` method (15-minute window):
```typescript
private readonly EDIT_WINDOW_MINUTES = 15;

async editMessage(userId: string, messageId: string, content: string) {
  const message = await this.prisma.chatMessage.findUnique({
    where: { id: messageId },
  });

  if (!message) throw new NotFoundException('Message not found');
  if (message.senderId !== userId) throw new ForbiddenException('Can only edit own messages');
  if (message.deletedAt) throw new BadRequestException('Cannot edit deleted message');

  const minutesSinceSent = (Date.now() - message.createdAt.getTime()) / 60000;
  if (minutesSinceSent > this.EDIT_WINDOW_MINUTES) {
    throw new BadRequestException('Edit window expired (15 minutes)');
  }

  return this.prisma.chatMessage.update({
    where: { id: messageId },
    data: { content, isEdited: true, editedAt: new Date() },
    include: { sender: { include: { profile: true } } },
  });
}
```

7. Add `deleteMessage` method (soft delete):
```typescript
async deleteMessage(userId: string, messageId: string) {
  const message = await this.prisma.chatMessage.findUnique({
    where: { id: messageId },
  });

  if (!message) throw new NotFoundException('Message not found');
  if (message.senderId !== userId) throw new ForbiddenException('Can only delete own messages');
  if (message.deletedAt) throw new BadRequestException('Message already deleted');

  return this.prisma.chatMessage.update({
    where: { id: messageId },
    data: { deletedAt: new Date(), content: null, attachmentUrl: null },
  });
}
```

8. Add `searchUsers` method for starting new conversations:
```typescript
async searchUsers(userId: string, query: string, limit = 20) {
  const user = await this.prisma.user.findUnique({
    where: { id: userId },
    select: { companyId: true },
  });

  if (!user) throw new NotFoundException('User not found');

  return this.prisma.user.findMany({
    where: {
      companyId: user.companyId,
      id: { not: userId },
      isActive: true,
      OR: [
        { email: { contains: query, mode: 'insensitive' } },
        { profile: { firstName: { contains: query, mode: 'insensitive' } } },
        { profile: { lastName: { contains: query, mode: 'insensitive' } } },
      ],
    },
    include: { profile: true },
    take: limit,
  });
}
```

9. Modify `getMessages` to include statuses and filter deleted:
```typescript
async getMessages(threadId: string, userId: string, options: { cursor?: string; limit?: number }) {
  const { cursor, limit = 50 } = options;

  const messages = await this.prisma.chatMessage.findMany({
    where: { threadId },
    take: -limit,
    skip: cursor ? 1 : 0,
    cursor: cursor ? { id: cursor } : undefined,
    orderBy: { createdAt: 'asc' },
    include: {
      sender: { include: { profile: true } },
      statuses: {
        select: { userId: true, deliveredAt: true, readAt: true },
      },
    },
  });

  const hasMore = messages.length === limit;

  return {
    messages,
    hasMore,
    cursor: messages.length > 0 ? messages[0].id : null,
  };
}
```

**Enhance ChatController** (`chat.controller.ts`):

1. Import DTOs and add ForbiddenException to imports
2. Update endpoints to use DTOs with validation
3. Add edit/delete endpoints:
```typescript
@Patch('messages/:messageId')
@ApiOperation({ summary: 'Edit message' })
async editMessage(
  @CurrentUser() user: any,
  @Param('messageId') messageId: string,
  @Body() body: EditMessageDto,
) {
  const data = await this.chatService.editMessage(user.id, messageId, body.content);
  return { success: true, data };
}

@Delete('messages/:messageId')
@ApiOperation({ summary: 'Delete message' })
async deleteMessage(
  @CurrentUser() user: any,
  @Param('messageId') messageId: string,
) {
  const data = await this.chatService.deleteMessage(user.id, messageId);
  return { success: true, data };
}
```

4. Add user search endpoint:
```typescript
@Get('users/search')
@ApiOperation({ summary: 'Search users for chat' })
async searchUsers(
  @CurrentUser() user: any,
  @Query('q') query: string,
  @Query('limit') limit?: number,
) {
  const data = await this.chatService.searchUsers(user.id, query || '', limit);
  return { success: true, data };
}
```

5. Update getMessages to pass userId and use cursor pagination:
```typescript
@Get('threads/:threadId/messages')
@ApiOperation({ summary: 'Get messages with pagination' })
async getMessages(
  @CurrentUser() user: any,
  @Param('threadId') threadId: string,
  @Query('cursor') cursor?: string,
  @Query('limit') limit?: number,
) {
  const data = await this.chatService.getMessages(threadId, user.id, { cursor, limit });
  return { success: true, data };
}
```

Add imports: `import { ForbiddenException } from '@nestjs/common';` and DTOs.
  </action>
  <verify>
1. `curl -X GET http://localhost:3001/chat/users/search?q=test -H "Authorization: Bearer $TOKEN"` returns users from same company
2. `curl -X PATCH http://localhost:3001/chat/messages/:id -H "Authorization: Bearer $TOKEN" -d '{"content":"edited"}'` returns 200 within 15 min, 400 after
3. `curl -X DELETE http://localhost:3001/chat/messages/:id -H "Authorization: Bearer $TOKEN"` soft-deletes (sets deletedAt)
4. API compiles with `npm run build` in apps/api
  </verify>
  <done>
ChatService has editMessage, deleteMessage, markDelivered, searchUsers methods. Controller has PATCH/DELETE message endpoints and user search. Company validation on thread creation. Message statuses created on send.
  </done>
</task>

</tasks>

<verification>
1. Schema: MessageStatus model exists with proper relations
2. API: Edit message within 15 min succeeds, after fails
3. API: Delete message sets deletedAt, clears content
4. API: User search returns only same-company users
5. API: Messages include statuses array when fetched
6. Build: `npm run build` succeeds in apps/api
</verification>

<success_criteria>
- MessageStatus model in schema with messageId, userId, deliveredAt, readAt
- ChatMessage has deletedAt field
- ChatService.editMessage enforces 15-min window
- ChatService.deleteMessage performs soft delete
- ChatService.searchUsers filters by companyId
- All endpoints compile and respond correctly
</success_criteria>

<output>
After completion, create `.planning/phases/06-chat/06-01-SUMMARY.md`
</output>
