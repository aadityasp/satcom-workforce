---
phase: 06-chat
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - apps/api/src/chat/chat.gateway.ts
  - apps/api/src/chat/chat.module.ts
autonomous: true

must_haves:
  truths:
    - "Messages sent via WebSocket appear instantly to all thread members"
    - "Users automatically join all their thread rooms on connect"
    - "Read receipts broadcast to message senders in real-time"
    - "Company isolation prevents cross-company message delivery"
  artifacts:
    - path: "apps/api/src/chat/chat.gateway.ts"
      provides: "Enhanced gateway with send, deliver, read events"
      contains: "@SubscribeMessage('chat:send')"
    - path: "apps/api/src/chat/chat.module.ts"
      provides: "Module with PrismaModule import"
      contains: "PrismaModule"
  key_links:
    - from: "apps/api/src/chat/chat.gateway.ts"
      to: "ChatService.sendMessage"
      via: "chat:send handler calls service"
      pattern: "chatService\\.sendMessage"
    - from: "apps/api/src/chat/chat.gateway.ts"
      to: "server.to(`thread:${threadId}`).emit('chat:message')"
      via: "Broadcast to thread room"
      pattern: "server\\.to.*emit\\('chat:message'"
---

<objective>
Enhance ChatGateway with company-scoped rooms, WebSocket message sending, delivery acknowledgments, and read receipt broadcasting.

Purpose: Enable real-time message delivery (< 500ms) per CHAT-03 requirement. All message events flow through WebSocket for instant updates.

Output: Enhanced ChatGateway that handles message sending, delivery confirmation, read receipts, and edit/delete notifications via WebSocket.
</objective>

<execution_context>
@/Users/adityaw/.claude/get-shit-done/workflows/execute-plan.md
@/Users/adityaw/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-chat/06-CONTEXT.md
@.planning/phases/06-chat/06-RESEARCH.md
@.planning/phases/06-chat/06-01-SUMMARY.md

@apps/api/src/chat/chat.gateway.ts
@apps/api/src/chat/chat.module.ts
@apps/api/src/chat/chat.service.ts
@apps/api/src/presence/presence.gateway.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update ChatModule to import required dependencies</name>
  <files>apps/api/src/chat/chat.module.ts</files>
  <action>
Update ChatModule to import PrismaModule if not already present. Ensure all required providers are available:

```typescript
import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { ChatController } from './chat.controller';
import { ChatService } from './chat.service';
import { ChatGateway } from './chat.gateway';
import { PrismaModule } from '../prisma/prisma.module';

@Module({
  imports: [
    PrismaModule,
    JwtModule.register({
      secret: process.env.JWT_SECRET,
      signOptions: { expiresIn: '15m' },
    }),
  ],
  controllers: [ChatController],
  providers: [ChatService, ChatGateway],
  exports: [ChatService, ChatGateway],
})
export class ChatModule {}
```

The gateway needs direct PrismaService access for room management on connect.
  </action>
  <verify>
`npm run build` in apps/api succeeds. ChatModule compiles without errors.
  </verify>
  <done>
ChatModule imports PrismaModule. JwtModule configured for token verification. ChatGateway exported for potential use by other modules.
  </done>
</task>

<task type="auto">
  <name>Task 2: Enhance ChatGateway with full real-time messaging</name>
  <files>apps/api/src/chat/chat.gateway.ts</files>
  <action>
Rewrite ChatGateway with comprehensive real-time features. Follow the presence.gateway.ts pattern for connection handling and multi-device tracking:

```typescript
/**
 * Chat Gateway - WebSocket handler for real-time messaging
 *
 * Handles:
 * - Connection with JWT auth and company-scoped rooms
 * - Real-time message sending via WebSocket
 * - Delivery acknowledgments
 * - Read receipt broadcasting
 * - Typing indicators
 * - Message edit/delete notifications
 */
import {
  WebSocketGateway,
  WebSocketServer,
  SubscribeMessage,
  ConnectedSocket,
  MessageBody,
  OnGatewayConnection,
  OnGatewayDisconnect,
} from '@nestjs/websockets';
import { Server, Socket } from 'socket.io';
import { Logger, Injectable } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { ChatService } from './chat.service';
import { PrismaService } from '../prisma/prisma.service';
import { ChatMessageType } from '@prisma/client';

interface SendMessagePayload {
  threadId: string;
  content: string;
  type?: ChatMessageType;
  attachmentUrl?: string;
  attachmentType?: string;
  tempId?: string;
}

@Injectable()
@WebSocketGateway({ cors: { origin: '*' }, namespace: 'chat' })
export class ChatGateway implements OnGatewayConnection, OnGatewayDisconnect {
  @WebSocketServer()
  server: Server;

  private readonly logger = new Logger(ChatGateway.name);
  private userSockets: Map<string, Set<string>> = new Map();

  constructor(
    private chatService: ChatService,
    private jwtService: JwtService,
    private prisma: PrismaService,
  ) {}

  async handleConnection(client: Socket) {
    try {
      const token = client.handshake.auth.token;
      if (!token) {
        this.logger.warn('Chat: Connection without token');
        client.disconnect();
        return;
      }

      const payload = this.jwtService.verify(token);
      const userId = payload.sub;
      const companyId = payload.companyId;

      // Store user data on socket
      client.data.userId = userId;
      client.data.companyId = companyId;

      // Track multi-device connections
      if (!this.userSockets.has(userId)) {
        this.userSockets.set(userId, new Set());
      }
      this.userSockets.get(userId)?.add(client.id);

      // Join company room for potential broadcast notifications
      client.join(`company:${companyId}`);

      // Join all user's thread rooms
      const memberships = await this.prisma.chatMember.findMany({
        where: { userId },
        select: { threadId: true },
      });

      for (const m of memberships) {
        client.join(`thread:${m.threadId}`);
      }

      this.logger.log(`Chat: User ${userId} connected (${memberships.length} threads)`);
    } catch (error) {
      this.logger.warn(`Chat: Connection failed - ${error.message}`);
      client.disconnect();
    }
  }

  handleDisconnect(client: Socket) {
    const userId = client.data.userId;
    if (userId) {
      this.userSockets.get(userId)?.delete(client.id);
      if (this.userSockets.get(userId)?.size === 0) {
        this.userSockets.delete(userId);
      }
      this.logger.log(`Chat: User ${userId} disconnected`);
    }
  }

  /**
   * Send a message via WebSocket
   * Returns acknowledgment with created message or error
   */
  @SubscribeMessage('chat:send')
  async handleSendMessage(
    @ConnectedSocket() client: Socket,
    @MessageBody() data: SendMessagePayload,
  ) {
    const userId = client.data.userId;
    if (!userId) {
      return { success: false, error: 'Not authenticated' };
    }

    try {
      const message = await this.chatService.sendMessage(userId, data.threadId, {
        type: data.type || ChatMessageType.Text,
        content: data.content,
        attachmentUrl: data.attachmentUrl,
        attachmentType: data.attachmentType,
        tempId: data.tempId,
      });

      // Broadcast to all members in thread room (including sender for multi-device)
      this.server.to(`thread:${data.threadId}`).emit('chat:message', {
        threadId: data.threadId,
        message,
        tempId: data.tempId, // For client-side deduplication
      });

      return { success: true, message };
    } catch (error) {
      this.logger.error(`Chat: Send failed - ${error.message}`);
      return { success: false, error: error.message };
    }
  }

  /**
   * Join a specific thread room (for newly created threads)
   */
  @SubscribeMessage('chat:join')
  handleJoinThread(
    @ConnectedSocket() client: Socket,
    @MessageBody() data: { threadId: string },
  ) {
    const userId = client.data.userId;
    if (!userId) return { success: false };

    client.join(`thread:${data.threadId}`);
    this.logger.debug(`Chat: User ${userId} joined thread ${data.threadId}`);
    return { success: true };
  }

  /**
   * Leave a thread room
   */
  @SubscribeMessage('chat:leave')
  handleLeaveThread(
    @ConnectedSocket() client: Socket,
    @MessageBody() data: { threadId: string },
  ) {
    const userId = client.data.userId;
    if (!userId) return { success: false };

    client.leave(`thread:${data.threadId}`);
    return { success: true };
  }

  /**
   * Mark messages as delivered (called when client receives messages)
   */
  @SubscribeMessage('chat:delivered')
  async handleDelivered(
    @ConnectedSocket() client: Socket,
    @MessageBody() data: { threadId: string; messageIds: string[] },
  ) {
    const userId = client.data.userId;
    if (!userId || !data.messageIds?.length) return;

    try {
      await this.chatService.markDelivered(data.messageIds, userId);

      // Get sender IDs and notify them
      const messages = await this.prisma.chatMessage.findMany({
        where: { id: { in: data.messageIds } },
        select: { id: true, senderId: true, threadId: true },
      });

      // Group by sender to minimize emissions
      const bySender = new Map<string, string[]>();
      for (const msg of messages) {
        if (msg.senderId !== userId) {
          if (!bySender.has(msg.senderId)) {
            bySender.set(msg.senderId, []);
          }
          bySender.get(msg.senderId)?.push(msg.id);
        }
      }

      // Emit delivery receipts to senders
      for (const [senderId, msgIds] of bySender) {
        this.emitToUser(senderId, 'chat:delivered', {
          threadId: data.threadId,
          messageIds: msgIds,
          userId,
          timestamp: new Date().toISOString(),
        });
      }
    } catch (error) {
      this.logger.error(`Chat: Delivery ack failed - ${error.message}`);
    }
  }

  /**
   * Mark thread as read and broadcast read receipts
   */
  @SubscribeMessage('chat:mark-read')
  async handleMarkRead(
    @ConnectedSocket() client: Socket,
    @MessageBody() data: { threadId: string },
  ) {
    const userId = client.data.userId;
    if (!userId) return;

    try {
      const readMessageIds = await this.chatService.markRead(userId, data.threadId);

      if (readMessageIds.length > 0) {
        // Get unique senders
        const messages = await this.prisma.chatMessage.findMany({
          where: { id: { in: readMessageIds } },
          select: { senderId: true },
          distinct: ['senderId'],
        });

        // Notify senders about read receipts
        for (const msg of messages) {
          if (msg.senderId !== userId) {
            this.emitToUser(msg.senderId, 'chat:read', {
              threadId: data.threadId,
              messageIds: readMessageIds,
              userId,
              timestamp: new Date().toISOString(),
            });
          }
        }
      }

      return { success: true };
    } catch (error) {
      this.logger.error(`Chat: Mark read failed - ${error.message}`);
      return { success: false, error: error.message };
    }
  }

  /**
   * Typing indicator start
   */
  @SubscribeMessage('chat:typing:start')
  handleTypingStart(
    @ConnectedSocket() client: Socket,
    @MessageBody() data: { threadId: string },
  ) {
    const userId = client.data.userId;
    if (!userId) return;

    // Broadcast to others in thread
    client.to(`thread:${data.threadId}`).emit('chat:typing:start', {
      threadId: data.threadId,
      userId,
    });
  }

  /**
   * Typing indicator stop
   */
  @SubscribeMessage('chat:typing:stop')
  handleTypingStop(
    @ConnectedSocket() client: Socket,
    @MessageBody() data: { threadId: string },
  ) {
    const userId = client.data.userId;
    if (!userId) return;

    client.to(`thread:${data.threadId}`).emit('chat:typing:stop', {
      threadId: data.threadId,
      userId,
    });
  }

  /**
   * Broadcast message edit to thread
   * Called from controller after successful edit
   */
  broadcastMessageEdit(threadId: string, message: any) {
    this.server.to(`thread:${threadId}`).emit('chat:message:edited', {
      threadId,
      message,
    });
  }

  /**
   * Broadcast message delete to thread
   * Called from controller after successful delete
   */
  broadcastMessageDelete(threadId: string, messageId: string) {
    this.server.to(`thread:${threadId}`).emit('chat:message:deleted', {
      threadId,
      messageId,
    });
  }

  /**
   * Broadcast new thread to members
   * Called when a new thread is created
   */
  broadcastNewThread(thread: any) {
    // Emit to each member
    for (const member of thread.members || []) {
      this.emitToUser(member.userId, 'chat:thread:created', { thread });
    }
  }

  /**
   * Helper: Emit to all sockets of a specific user (for multi-device)
   */
  private emitToUser(userId: string, event: string, data: any) {
    const sockets = this.userSockets.get(userId);
    if (sockets) {
      for (const socketId of sockets) {
        this.server.to(socketId).emit(event, data);
      }
    }
  }

  /**
   * Check if user is online (has active socket)
   */
  isUserOnline(userId: string): boolean {
    return this.userSockets.has(userId) && (this.userSockets.get(userId)?.size ?? 0) > 0;
  }
}
```

Key features implemented:
1. **Connection handling** - JWT verification, company ID extraction, join thread rooms
2. **Multi-device tracking** - Map<userId, Set<socketId>> pattern from presence gateway
3. **chat:send** - WebSocket message sending with acknowledgment
4. **chat:delivered** - Delivery confirmations with broadcast to sender
5. **chat:mark-read** - Read receipts with broadcast to senders
6. **chat:typing:start/stop** - Typing indicators
7. **Broadcast methods** - For edit/delete notifications from controller
8. **Company isolation** - companyId stored on socket for potential filtering
  </action>
  <verify>
1. `npm run build` in apps/api succeeds
2. Gateway compiles without errors
3. Connect to ws://localhost:3001/chat with valid token - should join thread rooms
4. Emit 'chat:send' with message - should broadcast to thread room
5. Emit 'chat:mark-read' - should update statuses and notify senders
  </verify>
  <done>
ChatGateway handles: connection with JWT auth, auto-join thread rooms, chat:send with broadcast, chat:delivered with sender notification, chat:mark-read with read receipts, typing indicators, and broadcast methods for edit/delete.
  </done>
</task>

</tasks>

<verification>
1. Module: ChatModule imports PrismaModule and exports ChatGateway
2. Gateway: Connects with JWT token and joins all user's thread rooms
3. Gateway: chat:send creates message and broadcasts to thread
4. Gateway: chat:delivered updates statuses and notifies senders
5. Gateway: chat:mark-read marks as read and broadcasts receipts
6. Gateway: Typing events broadcast to thread room
7. Build: `npm run build` succeeds in apps/api
</verification>

<success_criteria>
- ChatGateway implements OnGatewayConnection and OnGatewayDisconnect
- Users auto-join all their thread rooms on connect
- chat:send emits chat:message to thread room
- chat:delivered updates MessageStatus and emits to sender
- chat:mark-read marks messages read and emits read receipts
- Multi-device support via userSockets Map
- All events compile and gateway starts without errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-chat/06-02-SUMMARY.md`
</output>
