---
phase: 03-timesheets-projects
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/src/projects/projects.module.ts
  - apps/api/src/projects/projects.service.ts
  - apps/api/src/projects/projects.controller.ts
  - apps/api/src/projects/dto/create-project.dto.ts
  - apps/api/src/projects/dto/update-project.dto.ts
  - apps/api/src/projects/dto/create-task.dto.ts
  - apps/api/src/projects/dto/update-task.dto.ts
  - apps/api/src/app.module.ts
autonomous: true

must_haves:
  truths:
    - "Super Admin can create new projects"
    - "Super Admin can edit existing projects"
    - "Super Admin can deactivate projects"
    - "Super Admin can create tasks within projects"
    - "Super Admin can edit/deactivate tasks"
    - "Non-admin users cannot access project management"
  artifacts:
    - path: "apps/api/src/projects/projects.module.ts"
      provides: "Projects module for NestJS"
      exports: ["ProjectsModule"]
    - path: "apps/api/src/projects/projects.service.ts"
      provides: "Project and task CRUD operations"
      exports: ["ProjectsService"]
    - path: "apps/api/src/projects/projects.controller.ts"
      provides: "Admin-only project/task endpoints"
      contains: "@Roles('SuperAdmin')"
  key_links:
    - from: "apps/api/src/projects/projects.controller.ts"
      to: "apps/api/src/auth/guards/roles.guard.ts"
      via: "@Roles decorator and RolesGuard"
      pattern: "@Roles.*SuperAdmin"
---

<objective>
Create admin-only API module for managing projects and tasks.

Purpose: Satisfy ADMN-04 - Super Admin can manage projects and tasks for timesheet categorization.
Output: New projects module with CRUD endpoints protected by role-based access.
</objective>

<execution_context>
@/Users/adityaw/.claude/get-shit-done/workflows/execute-plan.md
@/Users/adityaw/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-timesheets-projects/03-CONTEXT.md
@.planning/phases/03-timesheets-projects/03-RESEARCH.md

@apps/api/src/auth/guards/roles.guard.ts
@apps/api/src/auth/decorators/roles.decorator.ts
@apps/api/prisma/schema.prisma
@apps/api/src/app.module.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create project/task DTOs</name>
  <files>
    apps/api/src/projects/dto/create-project.dto.ts
    apps/api/src/projects/dto/update-project.dto.ts
    apps/api/src/projects/dto/create-task.dto.ts
    apps/api/src/projects/dto/update-task.dto.ts
  </files>
  <action>
Create DTOs directory and files:

**create-project.dto.ts:**
```typescript
import { IsString, IsOptional, IsUUID, MinLength, MaxLength } from 'class-validator';
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';

export class CreateProjectDto {
  @ApiProperty({ minLength: 3, maxLength: 50 })
  @IsString()
  @MinLength(3)
  @MaxLength(50)
  name: string;

  @ApiProperty({ minLength: 2, maxLength: 10 })
  @IsString()
  @MinLength(2)
  @MaxLength(10)
  code: string;  // Unique project code like "PROJ-001"

  @ApiPropertyOptional()
  @IsOptional()
  @IsString()
  description?: string;

  @ApiPropertyOptional()
  @IsOptional()
  @IsUUID()
  managerId?: string;
}
```

**update-project.dto.ts:**
```typescript
import { PartialType } from '@nestjs/swagger';
import { IsOptional, IsBoolean } from 'class-validator';
import { CreateProjectDto } from './create-project.dto';

export class UpdateProjectDto extends PartialType(CreateProjectDto) {
  @IsOptional()
  @IsBoolean()
  isActive?: boolean;
}
```

**create-task.dto.ts:**
```typescript
import { IsString, IsOptional, IsUUID, MinLength, MaxLength } from 'class-validator';
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';

export class CreateTaskDto {
  @ApiProperty()
  @IsUUID()
  projectId: string;

  @ApiProperty({ minLength: 3, maxLength: 50 })
  @IsString()
  @MinLength(3)
  @MaxLength(50)
  name: string;

  @ApiProperty({ minLength: 2, maxLength: 10 })
  @IsString()
  @MinLength(2)
  @MaxLength(10)
  code: string;  // Unique within project, e.g., "DEV", "QA"

  @ApiPropertyOptional()
  @IsOptional()
  @IsString()
  description?: string;
}
```

**update-task.dto.ts:**
```typescript
import { PartialType, OmitType } from '@nestjs/swagger';
import { IsOptional, IsBoolean } from 'class-validator';
import { CreateTaskDto } from './create-task.dto';

export class UpdateTaskDto extends PartialType(OmitType(CreateTaskDto, ['projectId'])) {
  @IsOptional()
  @IsBoolean()
  isActive?: boolean;
}
```
  </action>
  <verify>
Run `npm run build --workspace=apps/api` - no TypeScript errors
  </verify>
  <done>DTOs created with validation decorators for project and task management</done>
</task>

<task type="auto">
  <name>Task 2: Create projects service with CRUD operations</name>
  <files>apps/api/src/projects/projects.service.ts</files>
  <action>
Create ProjectsService:

```typescript
import { Injectable, NotFoundException, ConflictException } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { CreateProjectDto } from './dto/create-project.dto';
import { UpdateProjectDto } from './dto/update-project.dto';
import { CreateTaskDto } from './dto/create-task.dto';
import { UpdateTaskDto } from './dto/update-task.dto';

@Injectable()
export class ProjectsService {
  constructor(private prisma: PrismaService) {}

  // ===== Projects =====

  async createProject(companyId: string, dto: CreateProjectDto) {
    // Check code uniqueness
    const existing = await this.prisma.project.findUnique({ where: { code: dto.code } });
    if (existing) {
      throw new ConflictException('Project code already exists');
    }

    return this.prisma.project.create({
      data: { companyId, ...dto },
      include: { tasks: true, manager: { include: { profile: true } } },
    });
  }

  async findAllProjects(companyId: string, includeInactive = false) {
    return this.prisma.project.findMany({
      where: { companyId, ...(includeInactive ? {} : { isActive: true }) },
      include: { tasks: { where: includeInactive ? {} : { isActive: true } }, manager: { include: { profile: true } } },
      orderBy: { name: 'asc' },
    });
  }

  async findProjectById(id: string) {
    const project = await this.prisma.project.findUnique({
      where: { id },
      include: { tasks: true, manager: { include: { profile: true } } },
    });
    if (!project) throw new NotFoundException('Project not found');
    return project;
  }

  async updateProject(id: string, dto: UpdateProjectDto) {
    await this.findProjectById(id); // Verify exists
    return this.prisma.project.update({
      where: { id },
      data: dto,
      include: { tasks: true, manager: { include: { profile: true } } },
    });
  }

  async deactivateProject(id: string) {
    return this.updateProject(id, { isActive: false });
  }

  // ===== Tasks =====

  async createTask(dto: CreateTaskDto) {
    // Verify project exists
    await this.findProjectById(dto.projectId);

    // Check code uniqueness within project
    const existing = await this.prisma.task.findUnique({
      where: { projectId_code: { projectId: dto.projectId, code: dto.code } },
    });
    if (existing) {
      throw new ConflictException('Task code already exists in this project');
    }

    return this.prisma.task.create({
      data: dto,
      include: { project: true },
    });
  }

  async findTaskById(id: string) {
    const task = await this.prisma.task.findUnique({
      where: { id },
      include: { project: true },
    });
    if (!task) throw new NotFoundException('Task not found');
    return task;
  }

  async updateTask(id: string, dto: UpdateTaskDto) {
    await this.findTaskById(id);
    return this.prisma.task.update({
      where: { id },
      data: dto,
      include: { project: true },
    });
  }

  async deactivateTask(id: string) {
    return this.updateTask(id, { isActive: false });
  }

  async findTasksByProject(projectId: string, includeInactive = false) {
    return this.prisma.task.findMany({
      where: { projectId, ...(includeInactive ? {} : { isActive: true }) },
      orderBy: { name: 'asc' },
    });
  }
}
```
  </action>
  <verify>
Run `npm run build --workspace=apps/api` - no TypeScript errors
  </verify>
  <done>ProjectsService handles all CRUD for projects and tasks with proper validation</done>
</task>

<task type="auto">
  <name>Task 3: Create projects controller and module with role protection</name>
  <files>
    apps/api/src/projects/projects.controller.ts
    apps/api/src/projects/projects.module.ts
    apps/api/src/app.module.ts
  </files>
  <action>
**Create projects.controller.ts:**

```typescript
import {
  Controller, Get, Post, Patch, Delete, Body, Param, Query, UseGuards,
} from '@nestjs/common';
import { ApiTags, ApiOperation, ApiBearerAuth, ApiQuery } from '@nestjs/swagger';
import { ProjectsService } from './projects.service';
import { CreateProjectDto } from './dto/create-project.dto';
import { UpdateProjectDto } from './dto/update-project.dto';
import { CreateTaskDto } from './dto/create-task.dto';
import { UpdateTaskDto } from './dto/update-task.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { RolesGuard } from '../auth/guards/roles.guard';
import { Roles } from '../auth/decorators/roles.decorator';
import { CurrentUser } from '../auth/decorators/current-user.decorator';

@ApiTags('Projects (Admin)')
@ApiBearerAuth()
@UseGuards(JwtAuthGuard, RolesGuard)
@Roles('SuperAdmin')  // All endpoints require SuperAdmin
@Controller('admin/projects')
export class ProjectsController {
  constructor(private readonly projectsService: ProjectsService) {}

  // ===== Projects =====

  @Post()
  @ApiOperation({ summary: 'Create project (SuperAdmin only)' })
  async createProject(@CurrentUser() user: any, @Body() dto: CreateProjectDto) {
    const result = await this.projectsService.createProject(user.companyId, dto);
    return { success: true, data: result };
  }

  @Get()
  @ApiOperation({ summary: 'List all projects' })
  @ApiQuery({ name: 'includeInactive', required: false, type: Boolean })
  async findAllProjects(
    @CurrentUser() user: any,
    @Query('includeInactive') includeInactive?: string,
  ) {
    const result = await this.projectsService.findAllProjects(
      user.companyId,
      includeInactive === 'true',
    );
    return { success: true, data: result };
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get project by ID' })
  async findProject(@Param('id') id: string) {
    const result = await this.projectsService.findProjectById(id);
    return { success: true, data: result };
  }

  @Patch(':id')
  @ApiOperation({ summary: 'Update project' })
  async updateProject(@Param('id') id: string, @Body() dto: UpdateProjectDto) {
    const result = await this.projectsService.updateProject(id, dto);
    return { success: true, data: result };
  }

  @Delete(':id')
  @ApiOperation({ summary: 'Deactivate project (soft delete)' })
  async deactivateProject(@Param('id') id: string) {
    const result = await this.projectsService.deactivateProject(id);
    return { success: true, data: result };
  }

  // ===== Tasks =====

  @Post('tasks')
  @ApiOperation({ summary: 'Create task in project' })
  async createTask(@Body() dto: CreateTaskDto) {
    const result = await this.projectsService.createTask(dto);
    return { success: true, data: result };
  }

  @Get(':projectId/tasks')
  @ApiOperation({ summary: 'List tasks in project' })
  @ApiQuery({ name: 'includeInactive', required: false, type: Boolean })
  async findTasks(
    @Param('projectId') projectId: string,
    @Query('includeInactive') includeInactive?: string,
  ) {
    const result = await this.projectsService.findTasksByProject(
      projectId,
      includeInactive === 'true',
    );
    return { success: true, data: result };
  }

  @Patch('tasks/:id')
  @ApiOperation({ summary: 'Update task' })
  async updateTask(@Param('id') id: string, @Body() dto: UpdateTaskDto) {
    const result = await this.projectsService.updateTask(id, dto);
    return { success: true, data: result };
  }

  @Delete('tasks/:id')
  @ApiOperation({ summary: 'Deactivate task (soft delete)' })
  async deactivateTask(@Param('id') id: string) {
    const result = await this.projectsService.deactivateTask(id);
    return { success: true, data: result };
  }
}
```

**Create projects.module.ts:**

```typescript
import { Module } from '@nestjs/common';
import { ProjectsController } from './projects.controller';
import { ProjectsService } from './projects.service';
import { PrismaModule } from '../prisma/prisma.module';

@Module({
  imports: [PrismaModule],
  controllers: [ProjectsController],
  providers: [ProjectsService],
  exports: [ProjectsService],
})
export class ProjectsModule {}
```

**Update app.module.ts:**

Add ProjectsModule to imports array:
```typescript
import { ProjectsModule } from './projects/projects.module';

@Module({
  imports: [
    // ... existing imports
    ProjectsModule,
  ],
  // ...
})
```
  </action>
  <verify>
Run `npm run build --workspace=apps/api`
Start API: `npm run dev --workspace=apps/api`
Verify Swagger UI shows `/admin/projects` endpoints
Test: Non-admin user should get 403 on any /admin/projects endpoint
  </verify>
  <done>
- ProjectsModule registered in app
- All endpoints protected by SuperAdmin role
- Swagger documentation generated
- CRUD operations for both projects and tasks
  </done>
</task>

</tasks>

<verification>
1. Build passes: `npm run build --workspace=apps/api`
2. Role protection:
   - Employee calling POST /admin/projects returns 403
   - SuperAdmin calling POST /admin/projects creates project
3. CRUD operations:
   - Create project with code
   - Create task with project reference
   - Update project name
   - Deactivate task
4. Swagger UI shows all new endpoints under "Projects (Admin)" tag
</verification>

<success_criteria>
- New ProjectsModule with controller, service, DTOs
- All endpoints require SuperAdmin role
- Projects have unique codes
- Tasks have unique codes within their project
- Soft delete via isActive flag
</success_criteria>

<output>
After completion, create `.planning/phases/03-timesheets-projects/03-02-SUMMARY.md`
</output>
