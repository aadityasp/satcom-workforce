---
phase: 07-reports-dashboards
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/src/reports/reports.module.ts
  - apps/api/src/reports/reports.service.ts
  - apps/api/src/reports/reports.controller.ts
  - apps/api/src/reports/dto/dashboard-response.dto.ts
  - apps/api/src/app.module.ts
autonomous: true

must_haves:
  truths:
    - "Manager can fetch dashboard data for direct reports only"
    - "HR can fetch org-wide dashboard data"
    - "API returns attendance, timesheet, and anomaly summaries"
  artifacts:
    - path: "apps/api/src/reports/reports.service.ts"
      provides: "Dashboard aggregation logic"
      exports: ["ReportsService"]
    - path: "apps/api/src/reports/reports.controller.ts"
      provides: "Dashboard API endpoints"
      exports: ["ReportsController"]
    - path: "apps/api/src/reports/dto/dashboard-response.dto.ts"
      provides: "Dashboard response type definitions"
  key_links:
    - from: "apps/api/src/reports/reports.controller.ts"
      to: "apps/api/src/reports/reports.service.ts"
      via: "dependency injection"
      pattern: "constructor.*ReportsService"
    - from: "apps/api/src/reports/reports.service.ts"
      to: "prisma"
      via: "database queries"
      pattern: "this\\.prisma\\."
---

<objective>
Create Reports API service and controller with dashboard aggregation endpoints for Manager and HR roles.

Purpose: Backend foundation for dashboard metrics - Manager sees team data, HR sees org-wide data.
Output: ReportsModule with ReportsService and ReportsController exposing GET /reports/dashboard endpoint.
</objective>

<execution_context>
@/Users/adityaw/.claude/get-shit-done/workflows/execute-plan.md
@/Users/adityaw/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-reports-dashboards/07-CONTEXT.md
@.planning/phases/07-reports-dashboards/07-RESEARCH.md

# Existing patterns to follow
@apps/api/src/anomalies/anomalies.service.ts (getSummary pattern)
@apps/api/src/attendance/attendance.service.ts (getSummary pattern)
@apps/api/src/timesheets/timesheets.service.ts (getSummary pattern)
@apps/api/src/admin/admin.service.ts (getDashboardSummary pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Reports DTOs</name>
  <files>apps/api/src/reports/dto/dashboard-response.dto.ts</files>
  <action>
Create dashboard response DTOs that define the shape of data returned by the API.

Create `apps/api/src/reports/dto/dashboard-response.dto.ts`:

```typescript
/**
 * Dashboard Response DTOs
 * Role-specific dashboard data structures
 */

// Common types
export interface AttendanceSummaryDto {
  date: string;
  checkedIn: number;
  late: number;
  absent: number;
  onLeave: number;
}

export interface TimesheetSummaryDto {
  projectId: string;
  projectName: string;
  totalMinutes: number;
  entryCount: number;
}

export interface TeamMemberStatusDto {
  userId: string;
  userName: string;
  checkInTime?: string;
  checkOutTime?: string;
  workMode?: string;
  isLate: boolean;
  isAbsent: boolean;
  currentProject?: string;
}

// Manager Dashboard Response
export interface ManagerDashboardDto {
  teamSize: number;
  todayStats: {
    checkedIn: number;
    late: number;
    absent: number;
    onLeave: number;
  };
  weeklyAttendance: AttendanceSummaryDto[];
  weeklyTimesheet: TimesheetSummaryDto[];
  teamStatus: TeamMemberStatusDto[];
  openAnomalies: number;
}

// HR Dashboard Response
export interface HRDashboardDto {
  orgSize: number;
  todayStats: {
    checkedIn: number;
    late: number;
    absent: number;
    onLeave: number;
    attendanceRate: number;
  };
  weeklyAttendance: AttendanceSummaryDto[];
  departmentBreakdown: {
    department: string;
    checkedIn: number;
    total: number;
  }[];
  anomalySummary: {
    open: number;
    acknowledged: number;
    byType: { type: string; count: number }[];
    bySeverity: { severity: string; count: number }[];
  };
  complianceMetrics: {
    avgCheckInTime: string | null;
    latePercentage: number;
    breakPolicyViolations: number;
  };
}
```

Export both DTOs for use in service and controller.
  </action>
  <verify>File exists and exports both ManagerDashboardDto and HRDashboardDto types</verify>
  <done>Dashboard DTOs created with team member status, attendance summary, and timesheet summary structures</done>
</task>

<task type="auto">
  <name>Task 2: Create Reports Service</name>
  <files>apps/api/src/reports/reports.service.ts</files>
  <action>
Create ReportsService following existing getSummary patterns from attendance.service.ts and anomalies.service.ts.

Create `apps/api/src/reports/reports.service.ts`:

```typescript
/**
 * Reports Service
 *
 * Aggregates dashboard data for Manager and HR roles.
 * Manager sees direct reports only, HR sees org-wide data.
 */

import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import {
  ManagerDashboardDto,
  HRDashboardDto,
  AttendanceSummaryDto,
  TimesheetSummaryDto,
  TeamMemberStatusDto
} from './dto/dashboard-response.dto';
import { AttendanceEventType, AnomalyStatus } from '@prisma/client';
import { startOfWeek, endOfWeek, eachDayOfInterval, format, subDays } from 'date-fns';

@Injectable()
export class ReportsService {
  constructor(private prisma: PrismaService) {}

  /**
   * Get Manager Dashboard - Direct reports only
   * CRITICAL: Filter by managerId to prevent data leakage
   */
  async getManagerDashboard(managerId: string, companyId: string): Promise<ManagerDashboardDto> {
    // Get direct reports - MUST filter by managerId
    const directReports = await this.prisma.employeeProfile.findMany({
      where: { managerId },
      select: { userId: true, firstName: true, lastName: true },
    });

    const userIds = directReports.map(u => u.userId);
    const teamSize = userIds.length;

    if (teamSize === 0) {
      return this.emptyManagerDashboard();
    }

    const today = new Date();
    today.setHours(0, 0, 0, 0);

    // Define late threshold: 9:15 AM
    const lateThreshold = new Date(today);
    lateThreshold.setHours(9, 15, 0, 0);

    // Parallel queries for performance
    const [todayAttendance, weeklyData, timesheetData, openAnomalies, leaveCount] = await Promise.all([
      // Today's attendance
      this.prisma.attendanceDay.findMany({
        where: { userId: { in: userIds }, date: today },
        include: {
          events: true,
          user: { include: { profile: true, presenceSession: true } }
        },
      }),
      // Weekly attendance (last 7 days)
      this.getWeeklyAttendance(userIds, today),
      // Weekly timesheet summary
      this.getWeeklyTimesheet(userIds, today),
      // Open anomalies count
      this.prisma.anomalyEvent.count({
        where: { userId: { in: userIds }, status: AnomalyStatus.Open },
      }),
      // On leave today
      this.prisma.leaveRequest.count({
        where: {
          userId: { in: userIds },
          status: 'Approved',
          startDate: { lte: today },
          endDate: { gte: today },
        },
      }),
    ]);

    // Calculate today's stats
    const checkedInUsers = todayAttendance.filter(d =>
      d.events.some(e => e.type === AttendanceEventType.CheckIn)
    );
    const lateUsers = todayAttendance.filter(d => {
      const checkIn = d.events.find(e => e.type === AttendanceEventType.CheckIn);
      return checkIn && new Date(checkIn.timestamp) > lateThreshold;
    });

    // Build team status list
    const teamStatus: TeamMemberStatusDto[] = directReports.map(profile => {
      const attendance = todayAttendance.find(a => a.userId === profile.userId);
      const checkIn = attendance?.events.find(e => e.type === AttendanceEventType.CheckIn);
      const checkOut = attendance?.events.find(e => e.type === AttendanceEventType.CheckOut);
      const isLate = checkIn ? new Date(checkIn.timestamp) > lateThreshold : false;

      return {
        userId: profile.userId,
        userName: `${profile.firstName} ${profile.lastName}`,
        checkInTime: checkIn?.timestamp.toISOString(),
        checkOutTime: checkOut?.timestamp.toISOString(),
        workMode: checkIn?.workMode,
        isLate,
        isAbsent: !checkIn,
        currentProject: attendance?.user.presenceSession?.currentProjectId || undefined,
      };
    });

    return {
      teamSize,
      todayStats: {
        checkedIn: checkedInUsers.length,
        late: lateUsers.length,
        absent: teamSize - checkedInUsers.length - leaveCount,
        onLeave: leaveCount,
      },
      weeklyAttendance: weeklyData,
      weeklyTimesheet: timesheetData,
      teamStatus,
      openAnomalies,
    };
  }

  /**
   * Get HR Dashboard - Org-wide data
   */
  async getHRDashboard(companyId: string): Promise<HRDashboardDto> {
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    // Get all active users in company
    const allUsers = await this.prisma.user.findMany({
      where: { companyId, isActive: true },
      select: { id: true },
    });
    const userIds = allUsers.map(u => u.id);
    const orgSize = userIds.length;

    if (orgSize === 0) {
      return this.emptyHRDashboard();
    }

    const lateThreshold = new Date(today);
    lateThreshold.setHours(9, 15, 0, 0);

    // Parallel queries
    const [
      todayAttendance,
      weeklyData,
      anomalySummary,
      leaveCount,
      breakViolations,
      avgCheckInData,
    ] = await Promise.all([
      // Today's attendance
      this.prisma.attendanceDay.findMany({
        where: { userId: { in: userIds }, date: today },
        include: { events: true },
      }),
      // Weekly attendance
      this.getWeeklyAttendance(userIds, today),
      // Anomaly summary
      this.getAnomalySummary(companyId),
      // On leave today
      this.prisma.leaveRequest.count({
        where: {
          userId: { in: userIds },
          status: 'Approved',
          startDate: { lte: today },
          endDate: { gte: today },
        },
      }),
      // Break policy violations this week
      this.prisma.anomalyEvent.count({
        where: {
          userId: { in: userIds },
          type: 'ExcessiveBreak',
          detectedAt: { gte: startOfWeek(today) },
        },
      }),
      // Average check-in time this week
      this.getAverageCheckInTime(userIds, today),
    ]);

    // Calculate today's stats
    const checkedIn = todayAttendance.filter(d =>
      d.events.some(e => e.type === AttendanceEventType.CheckIn)
    ).length;
    const late = todayAttendance.filter(d => {
      const checkIn = d.events.find(e => e.type === AttendanceEventType.CheckIn);
      return checkIn && new Date(checkIn.timestamp) > lateThreshold;
    }).length;

    const absent = orgSize - checkedIn - leaveCount;

    return {
      orgSize,
      todayStats: {
        checkedIn,
        late,
        absent,
        onLeave: leaveCount,
        attendanceRate: Math.round((checkedIn / orgSize) * 100 * 10) / 10,
      },
      weeklyAttendance: weeklyData,
      departmentBreakdown: [], // Can be extended with department data if schema supports it
      anomalySummary,
      complianceMetrics: {
        avgCheckInTime: avgCheckInData,
        latePercentage: checkedIn > 0 ? Math.round((late / checkedIn) * 100 * 10) / 10 : 0,
        breakPolicyViolations: breakViolations,
      },
    };
  }

  // Helper methods

  private async getWeeklyAttendance(userIds: string[], today: Date): Promise<AttendanceSummaryDto[]> {
    const weekStart = subDays(today, 6);
    const days = eachDayOfInterval({ start: weekStart, end: today });

    const lateThreshold = new Date();
    lateThreshold.setHours(9, 15, 0, 0);

    const results: AttendanceSummaryDto[] = [];

    for (const day of days) {
      const dayStart = new Date(day);
      dayStart.setHours(0, 0, 0, 0);

      const [attendance, leaveCount] = await Promise.all([
        this.prisma.attendanceDay.findMany({
          where: { userId: { in: userIds }, date: dayStart },
          include: { events: true },
        }),
        this.prisma.leaveRequest.count({
          where: {
            userId: { in: userIds },
            status: 'Approved',
            startDate: { lte: dayStart },
            endDate: { gte: dayStart },
          },
        }),
      ]);

      const checkedIn = attendance.filter(d =>
        d.events.some(e => e.type === AttendanceEventType.CheckIn)
      ).length;

      const dayLateThreshold = new Date(dayStart);
      dayLateThreshold.setHours(9, 15, 0, 0);

      const late = attendance.filter(d => {
        const checkIn = d.events.find(e => e.type === AttendanceEventType.CheckIn);
        return checkIn && new Date(checkIn.timestamp) > dayLateThreshold;
      }).length;

      results.push({
        date: format(day, 'yyyy-MM-dd'),
        checkedIn,
        late,
        absent: userIds.length - checkedIn - leaveCount,
        onLeave: leaveCount,
      });
    }

    return results;
  }

  private async getWeeklyTimesheet(userIds: string[], today: Date): Promise<TimesheetSummaryDto[]> {
    const weekStart = subDays(today, 6);

    const entries = await this.prisma.timesheetEntry.findMany({
      where: {
        userId: { in: userIds },
        date: { gte: weekStart, lte: today },
      },
      include: { project: true },
    });

    // Group by project
    const byProject = entries.reduce((acc, e) => {
      if (!acc[e.projectId]) {
        acc[e.projectId] = {
          projectId: e.projectId,
          projectName: e.project.name,
          totalMinutes: 0,
          entryCount: 0,
        };
      }
      acc[e.projectId].totalMinutes += e.minutes;
      acc[e.projectId].entryCount += 1;
      return acc;
    }, {} as Record<string, TimesheetSummaryDto>);

    return Object.values(byProject).sort((a, b) => b.totalMinutes - a.totalMinutes);
  }

  private async getAnomalySummary(companyId: string) {
    const anomalies = await this.prisma.anomalyEvent.findMany({
      where: { user: { companyId } },
      select: { status: true, type: true, severity: true },
    });

    const open = anomalies.filter(a => a.status === AnomalyStatus.Open).length;
    const acknowledged = anomalies.filter(a => a.status === AnomalyStatus.Acknowledged).length;

    const byType = Object.entries(
      anomalies.reduce((acc, a) => {
        acc[a.type] = (acc[a.type] || 0) + 1;
        return acc;
      }, {} as Record<string, number>)
    ).map(([type, count]) => ({ type, count }));

    const bySeverity = Object.entries(
      anomalies.reduce((acc, a) => {
        acc[a.severity] = (acc[a.severity] || 0) + 1;
        return acc;
      }, {} as Record<string, number>)
    ).map(([severity, count]) => ({ severity, count }));

    return { open, acknowledged, byType, bySeverity };
  }

  private async getAverageCheckInTime(userIds: string[], today: Date): Promise<string | null> {
    const weekStart = subDays(today, 6);

    const checkIns = await this.prisma.attendanceEvent.findMany({
      where: {
        type: AttendanceEventType.CheckIn,
        attendanceDay: {
          userId: { in: userIds },
          date: { gte: weekStart, lte: today },
        },
      },
      select: { timestamp: true },
    });

    if (checkIns.length === 0) return null;

    const totalMinutes = checkIns.reduce((sum, c) => {
      const d = new Date(c.timestamp);
      return sum + d.getHours() * 60 + d.getMinutes();
    }, 0);

    const avgMinutes = Math.round(totalMinutes / checkIns.length);
    const hours = Math.floor(avgMinutes / 60);
    const minutes = avgMinutes % 60;

    return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
  }

  private emptyManagerDashboard(): ManagerDashboardDto {
    return {
      teamSize: 0,
      todayStats: { checkedIn: 0, late: 0, absent: 0, onLeave: 0 },
      weeklyAttendance: [],
      weeklyTimesheet: [],
      teamStatus: [],
      openAnomalies: 0,
    };
  }

  private emptyHRDashboard(): HRDashboardDto {
    return {
      orgSize: 0,
      todayStats: { checkedIn: 0, late: 0, absent: 0, onLeave: 0, attendanceRate: 0 },
      weeklyAttendance: [],
      departmentBreakdown: [],
      anomalySummary: { open: 0, acknowledged: 0, byType: [], bySeverity: [] },
      complianceMetrics: { avgCheckInTime: null, latePercentage: 0, breakPolicyViolations: 0 },
    };
  }
}
```

Key implementation notes:
- Manager dashboard MUST filter by managerId (security critical)
- Use Promise.all for parallel queries (performance)
- Follow existing getSummary pattern structure
- Late threshold is 9:15 AM (configurable later via policy)
  </action>
  <verify>`grep -r "getManagerDashboard\|getHRDashboard" apps/api/src/reports/` returns both methods</verify>
  <done>ReportsService created with getManagerDashboard (filters by managerId) and getHRDashboard (org-wide) methods</done>
</task>

<task type="auto">
  <name>Task 3: Create Reports Controller and Module</name>
  <files>
    apps/api/src/reports/reports.controller.ts
    apps/api/src/reports/reports.module.ts
    apps/api/src/app.module.ts
  </files>
  <action>
Create ReportsController and ReportsModule, then register in AppModule.

1. Create `apps/api/src/reports/reports.controller.ts`:

```typescript
/**
 * Reports Controller
 *
 * Exposes dashboard endpoints for Manager and HR roles.
 * Single endpoint with role-based response.
 */

import { Controller, Get, UseGuards, Req } from '@nestjs/common';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { RolesGuard } from '../auth/guards/roles.guard';
import { Roles } from '../auth/decorators/roles.decorator';
import { ReportsService } from './reports.service';

@Controller('reports')
@UseGuards(JwtAuthGuard, RolesGuard)
export class ReportsController {
  constructor(private reportsService: ReportsService) {}

  /**
   * GET /reports/dashboard
   * Returns role-specific dashboard data:
   * - Manager: Team data (direct reports only)
   * - HR/SuperAdmin: Org-wide data
   */
  @Get('dashboard')
  @Roles('Manager', 'HR', 'SuperAdmin')
  async getDashboard(@Req() req: any) {
    const { id: userId, companyId, role } = req.user;

    if (role === 'Manager') {
      return this.reportsService.getManagerDashboard(userId, companyId);
    }

    // HR and SuperAdmin get org-wide dashboard
    return this.reportsService.getHRDashboard(companyId);
  }

  /**
   * GET /reports/dashboard/manager
   * Explicit Manager endpoint (for clarity)
   */
  @Get('dashboard/manager')
  @Roles('Manager')
  async getManagerDashboard(@Req() req: any) {
    const { id: userId, companyId } = req.user;
    return this.reportsService.getManagerDashboard(userId, companyId);
  }

  /**
   * GET /reports/dashboard/hr
   * Explicit HR/Admin endpoint (for clarity)
   */
  @Get('dashboard/hr')
  @Roles('HR', 'SuperAdmin')
  async getHRDashboard(@Req() req: any) {
    const { companyId } = req.user;
    return this.reportsService.getHRDashboard(companyId);
  }
}
```

2. Create `apps/api/src/reports/reports.module.ts`:

```typescript
import { Module } from '@nestjs/common';
import { ReportsController } from './reports.controller';
import { ReportsService } from './reports.service';
import { PrismaModule } from '../prisma/prisma.module';

@Module({
  imports: [PrismaModule],
  controllers: [ReportsController],
  providers: [ReportsService],
  exports: [ReportsService],
})
export class ReportsModule {}
```

3. Update `apps/api/src/app.module.ts`:
   - Import ReportsModule from './reports/reports.module'
   - Add ReportsModule to imports array

The endpoint structure:
- GET /reports/dashboard - Auto-detects role, returns appropriate data
- GET /reports/dashboard/manager - Explicit manager endpoint
- GET /reports/dashboard/hr - Explicit HR/SuperAdmin endpoint
  </action>
  <verify>
Run `curl -X GET http://localhost:3001/api/reports/dashboard -H "Authorization: Bearer $TOKEN"` returns dashboard data (after API restart).
Alternative: Check that files exist and module is registered in app.module.ts
  </verify>
  <done>ReportsController created with GET /reports/dashboard endpoint, ReportsModule registered in AppModule</done>
</task>

</tasks>

<verification>
1. All files exist in apps/api/src/reports/ directory
2. ReportsModule is imported in app.module.ts
3. Service methods filter correctly by role:
   - Manager: only sees direct reports (managerId filter)
   - HR/SuperAdmin: sees org-wide data (companyId filter)
4. TypeScript compiles without errors: `npm run build --workspace=@satcom/api`
</verification>

<success_criteria>
- GET /reports/dashboard returns ManagerDashboardDto for Manager role
- GET /reports/dashboard returns HRDashboardDto for HR/SuperAdmin role
- Manager dashboard filters by managerId (security verified)
- API compiles and starts without errors
</success_criteria>

<output>
After completion, create `.planning/phases/07-reports-dashboards/07-01-SUMMARY.md`
</output>
