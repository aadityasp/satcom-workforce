---
phase: 08-mobile-app
plan: 05
type: execute
wave: 3
depends_on: ["08-01"]
files_modified:
  - apps/mobile/src/store/chat.ts
  - apps/mobile/src/hooks/useChat.ts
  - apps/mobile/src/components/chat/ConversationItem.tsx
  - apps/mobile/src/components/chat/MessageBubble.tsx
  - apps/mobile/src/components/chat/ChatInput.tsx
  - apps/mobile/app/chat/_layout.tsx
  - apps/mobile/app/chat/index.tsx
  - apps/mobile/app/chat/[threadId].tsx
  - apps/mobile/app/(tabs)/_layout.tsx
autonomous: true

must_haves:
  truths:
    - "User can view conversation list"
    - "User can send and receive messages"
    - "Messages appear in real-time"
    - "User can create new conversations"
    - "Typing indicators show"
  artifacts:
    - path: "apps/mobile/src/store/chat.ts"
      provides: "Chat state with Socket.IO and mobile reconnection"
      exports: ["useChatStore", "useTypingUsers", "useConversationMessages"]
    - path: "apps/mobile/src/hooks/useChat.ts"
      provides: "Chat hook with auto-connect"
      exports: ["useChat", "useConversationList", "useMessages"]
    - path: "apps/mobile/app/chat/[threadId].tsx"
      provides: "Message thread screen"
  key_links:
    - from: "apps/mobile/src/store/chat.ts"
      to: "socket.io-client"
      via: "WebSocket connection"
      pattern: "io\\("
    - from: "apps/mobile/src/store/chat.ts"
      to: "AppState"
      via: "reconnect on foreground"
      pattern: "AppState.addEventListener"
---

<objective>
Implement mobile chat with real-time messaging for 1:1 and group conversations.

Purpose: Allow employees to communicate with team members via direct messages and group chats on mobile.
Output: Working chat with conversation list, message threads, real-time delivery, and typing indicators.
</objective>

<execution_context>
@/Users/adityaw/.claude/get-shit-done/workflows/execute-plan.md
@/Users/adityaw/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/08-mobile-app/08-RESEARCH.md

# Web patterns to mirror
@apps/web/src/store/chat.ts
@apps/web/src/hooks/useChat.ts

# Mobile foundation
@apps/mobile/src/lib/api.ts
@apps/mobile/src/store/auth.ts
@apps/mobile/src/theme/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create mobile chat store with reconnection</name>
  <files>apps/mobile/src/store/chat.ts</files>
  <action>
Create `apps/mobile/src/store/chat.ts` - Zustand store mirroring web with mobile reconnection:

1. Import:
   - `create` from zustand
   - `io, Socket` from socket.io-client
   - `AppState, AppStateStatus` from react-native
   - `NetInfo` from @react-native-community/netinfo

2. Define same types as web chat store:
   - `MessageStatus`, `MessageRecipientStatus`
   - `ChatMessage`, `Conversation`

3. Define `ChatState` interface matching web:
   - socket, isConnected, connectionError, currentUserId
   - conversations, activeConversationId, isLoadingConversations
   - messages (Map), hasMoreMessages (Map), isLoadingMessages
   - typingUsers (Map)
   - All the same actions

4. `SOCKET_URL` from `EXPO_PUBLIC_API_URL`

5. `connect(token: string)` - MIRROR WEB exactly but add mobile reconnection:

   Socket config (same as presence):
   ```typescript
   const socket = io(`${SOCKET_URL}/chat`, {
     auth: { token },
     autoConnect: true,
     reconnection: true,
     reconnectionAttempts: 10,
     reconnectionDelay: 1000,
     reconnectionDelayMax: 10000,
     timeout: 20000,
   });
   ```

   All same event handlers as web:
   - connect, disconnect, connect_error
   - chat:message, chat:delivered, chat:read
   - chat:edited, chat:deleted
   - chat:thread:created
   - chat:typing:start, chat:typing:stop

   **Mobile additions:**
   ```typescript
   // Reconnect on foreground
   const appStateSubscription = AppState.addEventListener('change', (nextState) => {
     if (nextState === 'active' && !socket.connected) {
       socket.connect();
     }
   });

   // Reconnect on network restore
   const netInfoUnsubscribe = NetInfo.addEventListener((state) => {
     if (state.isConnected && !socket.connected) {
       socket.connect();
     }
   });
   ```

   Extract userId from JWT (same as web):
   ```typescript
   try {
     const payload = JSON.parse(atob(token.split('.')[1]));
     set({ currentUserId: payload.sub });
   } catch {}
   ```

6. All same action implementations as web:
   - setConversations, setActiveConversation, addConversation, updateUnreadCount
   - setMessages, addMessage, updateMessage, prependMessages
   - sendMessage (with optimistic update and tempId)
   - markAsRead, startTyping, stopTyping, joinThread
   - setLoadingConversations, setLoadingMessages

7. Export same selectors:
   - `useTypingUsers(threadId)`
   - `useConversationMessages(threadId)`
   - `useHasMoreMessages(threadId)`
   - `useTotalUnreadCount()`
   - `useActiveConversation()`

This is largely a copy of web store with mobile reconnection added.
  </action>
  <verify>
`cd apps/mobile && npm run typecheck` passes.
Store has all same exports as web version.
  </verify>
  <done>
Chat store created mirroring web with mobile reconnection.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useChat hook and chat components</name>
  <files>
    apps/mobile/src/hooks/useChat.ts
    apps/mobile/src/components/chat/ConversationItem.tsx
    apps/mobile/src/components/chat/MessageBubble.tsx
    apps/mobile/src/components/chat/ChatInput.tsx
  </files>
  <action>
**1. Create `apps/mobile/src/hooks/useChat.ts`:**

Hooks for chat functionality:

```typescript
// Auto-connect and fetch conversations
export function useChat() {
  // Connect to socket on mount (if have token)
  // Return connection state and methods
}

// Fetch conversation list
export function useConversationList() {
  conversations: Conversation[];
  isLoading: boolean;
  refresh: () => Promise<void>;
  createConversation: (userIds: string[], name?: string) => Promise<Conversation | null>;
}

// Fetch messages for a thread
export function useMessages(threadId: string) {
  messages: ChatMessage[];
  isLoading: boolean;
  hasMore: boolean;
  loadMore: () => Promise<void>;
  sendMessage: (content: string) => Promise<void>;
  markAsRead: () => void;
}
```

Implementation:
- `useChat()`: Connects socket using auth token, returns isConnected
- `useConversationList()`:
  - Fetches GET `/chat/threads` on mount
  - Sets in store via setConversations
  - createConversation: POST `/chat/threads` with userIds
- `useMessages(threadId)`:
  - Fetches GET `/chat/threads/{id}/messages?take=50` on mount
  - loadMore: Uses cursor pagination
  - sendMessage: Uses store.sendMessage (socket emit)
  - markAsRead: Uses store.markAsRead

**2. Create `apps/mobile/src/components/chat/ConversationItem.tsx`:**

List item for conversation:

Props: `conversation: Conversation`, `onPress: () => void`, `currentUserId: string`

UI:
- Avatar (for DM: other user's avatar, for Group: group icon)
- Name (for DM: other user's name, for Group: group name)
- Last message preview (truncated, or "No messages yet")
- Timestamp (relative: "2m ago", "Yesterday")
- Unread badge (number if > 0)
- TouchableOpacity wrapper

**3. Create `apps/mobile/src/components/chat/MessageBubble.tsx`:**

Individual message display:

Props: `message: ChatMessage`, `isOwnMessage: boolean`, `showSender: boolean`

UI:
- Aligned right if own message (blue background)
- Aligned left if other's message (gray background)
- Sender name if showSender and not own message (for groups)
- Message content
- Timestamp (small, below message)
- Status indicator for own messages: checkmark for sent, double-check for delivered, blue double-check for read
- "Message deleted" placeholder if deletedAt

Handle deleted messages, edited messages (show "edited" label).

**4. Create `apps/mobile/src/components/chat/ChatInput.tsx`:**

Message input component:

Props: `onSend: (content: string) => void`, `onTypingStart: () => void`, `onTypingStop: () => void`, `disabled?: boolean`

UI:
- TextInput with multiline support
- Send button (airplane icon)
- Send button disabled if empty or disabled prop

Typing indicator logic:
- Call onTypingStart when user starts typing (debounced)
- Call onTypingStop when user stops typing (after 2s delay)
- Use useRef to track timeout
  </action>
  <verify>
`cd apps/mobile && npm run typecheck` passes.
All components and hooks export correctly.
  </verify>
  <done>
Chat hooks provide conversation and message management.
Chat components ready for use in screens.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create chat screens and navigation</name>
  <files>
    apps/mobile/app/chat/_layout.tsx
    apps/mobile/app/chat/index.tsx
    apps/mobile/app/chat/[threadId].tsx
    apps/mobile/app/(tabs)/_layout.tsx
  </files>
  <action>
**1. Create `apps/mobile/app/chat/_layout.tsx`:**

Stack layout for chat screens:

```tsx
import { Stack } from 'expo-router';
import { colors } from '../../src/theme';

export default function ChatLayout() {
  return (
    <Stack
      screenOptions={{
        headerStyle: { backgroundColor: '#FFFFFF' },
        headerTitleStyle: { color: colors.navy[900], fontWeight: '600' },
        headerTintColor: colors.blue[600],
      }}
    >
      <Stack.Screen name="index" options={{ title: 'Messages' }} />
      <Stack.Screen name="[threadId]" options={{ title: 'Chat' }} />
    </Stack>
  );
}
```

**2. Create `apps/mobile/app/chat/index.tsx`:**

Conversation list screen:

- Use `useChat()` for connection
- Use `useConversationList()` for data
- Use `useChatStore()` to get currentUserId

UI:
- Header: "Messages" with New Chat button (+ icon)
- FlatList of ConversationItem
- Empty state: "No conversations yet. Start a new chat!"
- Pull to refresh

New Chat flow:
- Button opens modal
- Modal shows user search (GET `/users/search?q={query}`)
- Select users -> create conversation -> navigate to thread

Navigation:
- ConversationItem onPress: `router.push(`/chat/${conversation.id}`)`

**3. Create `apps/mobile/app/chat/[threadId].tsx`:**

Message thread screen:

- Get `threadId` from `useLocalSearchParams()`
- Use `useMessages(threadId)` for messages
- Use `useTypingUsers(threadId)` for typing indicators
- Use `useChatStore()` for currentUserId

UI Layout (KeyboardAvoidingView):
```
Header: Conversation name (set via navigation options)

FlatList (inverted for chat):
  - MessageBubble items
  - "Load more" at top if hasMore
  - Typing indicator at bottom

ChatInput at bottom
```

Implementation:
- Set header title dynamically based on conversation
- FlatList inverted (newest at bottom)
- Load more triggers loadMore()
- Send triggers sendMessage() and scrolls to bottom
- Mark as read on mount and when receiving messages
- Typing indicator shows "X is typing..." with animation

Typing indicators:
- ChatInput.onTypingStart -> store.startTyping(threadId)
- ChatInput.onTypingStop -> store.stopTyping(threadId)

**4. Update `apps/mobile/app/(tabs)/_layout.tsx`:**

Add chat access from tabs (Messages quick action on dashboard navigates here):

The tab layout already exists. Just ensure the Messages quick action card on dashboard can navigate to chat:

Actually, chat is a separate stack, not a tab. Update the quick action in dashboard (index.tsx) to navigate to `/chat`:

```tsx
// In dashboard quick actions
<TouchableOpacity
  style={styles.actionCard}
  onPress={() => router.push('/chat')}
>
```

This was already set up, just verify the navigation path is `/chat`.
  </action>
  <verify>
`cd apps/mobile && npm run typecheck` passes.
Chat screens exist with navigation structure.
Can navigate from dashboard to chat.
  </verify>
  <done>
Chat screens implemented:
- Conversation list with new chat creation
- Message thread with real-time messaging
- Typing indicators working
- Navigation integrated
  </done>
</task>

</tasks>

<verification>
1. `cd apps/mobile && npm run typecheck` passes
2. Can view conversation list
3. Can create new conversation
4. Can send and receive messages
5. Messages appear in real-time
6. Typing indicators show
7. Read receipts update
</verification>

<success_criteria>
- User can chat (1:1 and groups) on mobile (MOBL-05)
- Conversation list shows all chats with unread counts
- Can create new 1:1 or group conversations
- Messages send and receive in real-time
- Typing indicators work
- Delivery/read receipts displayed
- Reconnects on foreground/network restore
</success_criteria>

<output>
After completion, create `.planning/phases/08-mobile-app/08-05-SUMMARY.md`
</output>
