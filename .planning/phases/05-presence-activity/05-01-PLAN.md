---
phase: 05-presence-activity
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/prisma/schema.prisma
  - apps/api/src/presence/presence.service.ts
  - apps/api/src/presence/presence.controller.ts
  - apps/api/src/presence/dto/update-presence.dto.ts
  - apps/api/src/presence/dto/set-activity.dto.ts
  - apps/api/src/presence/dto/post-status.dto.ts
autonomous: true

must_haves:
  truths:
    - "User can set current task/project and it persists"
    - "User can post a status message visible to team"
    - "GPS coordinates are captured on presence update"
    - "Manager can view team's current activities"
    - "Team list can be filtered by status and department"
  artifacts:
    - path: "apps/api/prisma/schema.prisma"
      provides: "Extended PresenceSession with statusMessage, GPS; ActivityLog model"
      contains: "statusMessage"
    - path: "apps/api/src/presence/presence.service.ts"
      provides: "Enhanced presence operations with GPS, filters, activity log"
      exports: ["PresenceService"]
    - path: "apps/api/src/presence/presence.controller.ts"
      provides: "REST endpoints for presence operations"
      exports: ["PresenceController"]
    - path: "apps/api/src/presence/dto/set-activity.dto.ts"
      provides: "DTO for setting current activity"
      exports: ["SetActivityDto"]
  key_links:
    - from: "apps/api/src/presence/presence.controller.ts"
      to: "apps/api/src/presence/presence.service.ts"
      via: "service injection"
      pattern: "this\\.presenceService\\."
    - from: "apps/api/src/presence/presence.service.ts"
      to: "prisma.presenceSession"
      via: "database operations"
      pattern: "prisma\\.presenceSession"
---

<objective>
Extend presence schema and API to support activity tracking with GPS capture, status messages, and manager team views.

Purpose: Enable real-time activity tracking (ACTV-01 through ACTV-06) and presence filtering (PRES-06) by enhancing the existing presence infrastructure with new fields and endpoints.

Output:
- Extended Prisma schema with statusMessage, GPS fields, ActivityLog model
- Enhanced PresenceService with GPS capture, department filtering, activity logging
- New REST endpoints for setting activity, posting status, manager team view
</objective>

<execution_context>
@/Users/adityaw/.claude/get-shit-done/workflows/execute-plan.md
@/Users/adityaw/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-presence-activity/05-RESEARCH.md

# Existing presence infrastructure
@apps/api/src/presence/presence.service.ts
@apps/api/src/presence/presence.controller.ts
@apps/api/prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend Prisma schema for activity tracking</name>
  <files>apps/api/prisma/schema.prisma</files>
  <action>
Add the following fields to the existing PresenceSession model:

```prisma
model PresenceSession {
  // ... existing fields ...
  statusMessage    String?          // ACTV-02: User's current status text
  statusUpdatedAt  DateTime?        // When status message was last set
  lastLatitude     Decimal?         @db.Decimal(10, 8)  // ACTV-06: GPS lat
  lastLongitude    Decimal?         @db.Decimal(11, 8)  // ACTV-06: GPS lon
}
```

Add new ActivityLog model for ACTV-04 (task time breakdown):

```prisma
model ActivityLog {
  id        String   @id @default(uuid())
  userId    String
  projectId String?
  taskId    String?
  startedAt DateTime @default(now())
  endedAt   DateTime?

  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  project Project? @relation(fields: [projectId], references: [id])
  task    Task?    @relation(fields: [taskId], references: [id])

  @@index([userId, startedAt])
  @@map("activity_logs")
}
```

Add the reverse relation in User model:
```prisma
activityLogs    ActivityLog[]
```

Add reverse relations in Project and Task models:
```prisma
// In Project model
activityLogs    ActivityLog[]

// In Task model
activityLogs    ActivityLog[]
```

After schema changes, run:
```bash
cd apps/api && npx prisma generate && npx prisma db push
```

Note: Use `db push` for development - no migration file needed.
  </action>
  <verify>
Run `cd apps/api && npx prisma validate` - should succeed with no errors.
Run `npx prisma db push` - should apply changes without errors.
Check that `npx prisma studio` shows the new fields on PresenceSession and new ActivityLog model.
  </verify>
  <done>
PresenceSession has statusMessage, statusUpdatedAt, lastLatitude, lastLongitude fields.
ActivityLog model exists with userId, projectId, taskId, startedAt, endedAt fields.
All relations properly defined and database schema updated.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create DTOs for presence operations</name>
  <files>
apps/api/src/presence/dto/update-presence.dto.ts
apps/api/src/presence/dto/set-activity.dto.ts
apps/api/src/presence/dto/post-status.dto.ts
apps/api/src/presence/dto/index.ts
  </files>
  <action>
Create `apps/api/src/presence/dto/` directory if it doesn't exist.

Create update-presence.dto.ts:
```typescript
import { ApiPropertyOptional } from '@nestjs/swagger';
import { IsOptional, IsString, IsNumber, Min, Max } from 'class-validator';

export class UpdatePresenceDto {
  @ApiPropertyOptional({ description: 'Current project ID' })
  @IsOptional()
  @IsString()
  projectId?: string;

  @ApiPropertyOptional({ description: 'Current task ID' })
  @IsOptional()
  @IsString()
  taskId?: string;

  @ApiPropertyOptional({ description: 'GPS latitude', minimum: -90, maximum: 90 })
  @IsOptional()
  @IsNumber()
  @Min(-90)
  @Max(90)
  latitude?: number;

  @ApiPropertyOptional({ description: 'GPS longitude', minimum: -180, maximum: 180 })
  @IsOptional()
  @IsNumber()
  @Min(-180)
  @Max(180)
  longitude?: number;
}
```

Create set-activity.dto.ts:
```typescript
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { IsString, IsOptional } from 'class-validator';

export class SetActivityDto {
  @ApiProperty({ description: 'Project ID to set as current activity' })
  @IsString()
  projectId: string;

  @ApiPropertyOptional({ description: 'Task ID within the project' })
  @IsOptional()
  @IsString()
  taskId?: string;
}
```

Create post-status.dto.ts:
```typescript
import { ApiProperty } from '@nestjs/swagger';
import { IsString, MaxLength, MinLength } from 'class-validator';

export class PostStatusDto {
  @ApiProperty({ description: 'Status message text', maxLength: 200 })
  @IsString()
  @MinLength(1)
  @MaxLength(200)
  message: string;
}
```

Create index.ts to export all DTOs:
```typescript
export * from './update-presence.dto';
export * from './set-activity.dto';
export * from './post-status.dto';
```
  </action>
  <verify>
Run `cd apps/api && npm run build` - should compile without TypeScript errors.
Check that all three DTO files exist in apps/api/src/presence/dto/.
  </verify>
  <done>
Three DTO files created with proper validation decorators.
All DTOs exported from index.ts barrel file.
TypeScript compilation succeeds.
  </done>
</task>

<task type="auto">
  <name>Task 3: Enhance PresenceService with GPS, filters, and activity logging</name>
  <files>apps/api/src/presence/presence.service.ts</files>
  <action>
Enhance the existing PresenceService with the following methods:

1. Update `updatePresence` to accept GPS coordinates and save to PresenceSession:
```typescript
async updatePresence(userId: string, data: {
  projectId?: string;
  taskId?: string;
  latitude?: number;
  longitude?: number;
}) {
  const now = new Date();

  // Get current session to check if activity changed
  const currentSession = await this.prisma.presenceSession.findUnique({
    where: { userId },
  });

  const activityChanged = currentSession && (
    currentSession.currentProjectId !== data.projectId ||
    currentSession.currentTaskId !== data.taskId
  );

  // If activity changed, close previous activity log and start new one
  if (activityChanged && currentSession.currentProjectId) {
    await this.prisma.activityLog.updateMany({
      where: {
        userId,
        endedAt: null,
      },
      data: { endedAt: now },
    });
  }

  // Start new activity log if project specified
  if (data.projectId && activityChanged) {
    await this.prisma.activityLog.create({
      data: {
        userId,
        projectId: data.projectId,
        taskId: data.taskId,
        startedAt: now,
      },
    });
  }

  return this.prisma.presenceSession.upsert({
    where: { userId },
    create: {
      userId,
      status: PresenceStatus.Online,
      lastSeenAt: now,
      currentProjectId: data.projectId,
      currentTaskId: data.taskId,
      lastLatitude: data.latitude,
      lastLongitude: data.longitude,
    },
    update: {
      status: PresenceStatus.Online,
      lastSeenAt: now,
      currentProjectId: data.projectId,
      currentTaskId: data.taskId,
      ...(data.latitude !== undefined && { lastLatitude: data.latitude }),
      ...(data.longitude !== undefined && { lastLongitude: data.longitude }),
    },
  });
}
```

2. Add `setActivity` method for ACTV-01:
```typescript
async setActivity(userId: string, projectId: string, taskId?: string) {
  const now = new Date();

  // Close any existing activity log
  await this.prisma.activityLog.updateMany({
    where: { userId, endedAt: null },
    data: { endedAt: now },
  });

  // Start new activity log
  await this.prisma.activityLog.create({
    data: {
      userId,
      projectId,
      taskId,
      startedAt: now,
    },
  });

  // Update presence session
  return this.prisma.presenceSession.upsert({
    where: { userId },
    create: {
      userId,
      status: PresenceStatus.Online,
      lastSeenAt: now,
      currentProjectId: projectId,
      currentTaskId: taskId,
    },
    update: {
      status: PresenceStatus.Online,
      lastSeenAt: now,
      currentProjectId: projectId,
      currentTaskId: taskId,
    },
  });
}
```

3. Add `postStatusUpdate` method for ACTV-02:
```typescript
async postStatusUpdate(userId: string, message: string) {
  const now = new Date();
  return this.prisma.presenceSession.upsert({
    where: { userId },
    create: {
      userId,
      status: PresenceStatus.Online,
      lastSeenAt: now,
      statusMessage: message,
      statusUpdatedAt: now,
    },
    update: {
      status: PresenceStatus.Online,
      lastSeenAt: now,
      statusMessage: message,
      statusUpdatedAt: now,
    },
  });
}
```

4. Add `clearStatus` method:
```typescript
async clearStatus(userId: string) {
  return this.prisma.presenceSession.update({
    where: { userId },
    data: {
      statusMessage: null,
      statusUpdatedAt: null,
    },
  });
}
```

5. Enhance `getAvailabilityList` to support filtering by status and department (PRES-06):
```typescript
async getAvailabilityList(companyId: string, filters?: {
  status?: PresenceStatus;
  department?: string;
}) {
  const sessions = await this.prisma.presenceSession.findMany({
    where: {
      user: {
        companyId,
        ...(filters?.department && {
          profile: { department: filters.department },
        }),
      },
    },
    include: {
      user: {
        include: { profile: true },
      },
    },
  });

  // ... rest of existing logic for project/task lookup ...

  // Apply status filter after calculating dynamic status
  let result = sessions.map((s) => {
    const elapsed = now - s.lastSeenAt.getTime();
    let status: PresenceStatus;
    if (elapsed < this.ONLINE_THRESHOLD) {
      status = PresenceStatus.Online;
    } else if (elapsed < this.AWAY_THRESHOLD) {
      status = PresenceStatus.Away;
    } else {
      status = PresenceStatus.Offline;
    }

    return {
      userId: s.userId,
      status,
      lastSeenAt: s.lastSeenAt,
      currentWorkMode: s.currentWorkMode,
      statusMessage: s.statusMessage,
      statusUpdatedAt: s.statusUpdatedAt,
      currentProject: project ? { id: project.id, name: project.name, code: project.code } : null,
      currentTask: task ? { id: task.id, name: task.name, code: task.code } : null,
      profile: s.user.profile ? {
        firstName: s.user.profile.firstName,
        lastName: s.user.profile.lastName,
        designation: s.user.profile.designation,
        department: s.user.profile.department,
        avatarUrl: s.user.profile.avatarUrl,
      } : null,
    };
  });

  // Apply status filter if specified
  if (filters?.status) {
    result = result.filter(r => r.status === filters.status);
  }

  return result;
}
```

6. Add `getTeamActivity` method for ACTV-05 (manager view):
```typescript
async getTeamActivity(
  requesterId: string,
  requesterRole: string,
  companyId: string,
  date: Date,
) {
  // Get team members based on role
  let userFilter: any = { companyId };

  if (requesterRole === 'Manager') {
    // Manager sees only their direct reports
    userFilter = {
      companyId,
      profile: { managerId: requesterId },
    };
  }
  // HR and SuperAdmin see all company users

  const users = await this.prisma.user.findMany({
    where: userFilter,
    include: {
      profile: true,
      presenceSession: true,
    },
  });

  const startOfDay = new Date(date);
  startOfDay.setHours(0, 0, 0, 0);
  const endOfDay = new Date(date);
  endOfDay.setHours(23, 59, 59, 999);

  // Get activity logs for the day
  const activityLogs = await this.prisma.activityLog.findMany({
    where: {
      userId: { in: users.map(u => u.id) },
      startedAt: { gte: startOfDay, lte: endOfDay },
    },
    include: {
      project: { select: { id: true, name: true, code: true } },
      task: { select: { id: true, name: true, code: true } },
    },
    orderBy: { startedAt: 'desc' },
  });

  return users.map(user => ({
    userId: user.id,
    profile: user.profile ? {
      firstName: user.profile.firstName,
      lastName: user.profile.lastName,
      designation: user.profile.designation,
      department: user.profile.department,
    } : null,
    presence: user.presenceSession ? {
      status: this.calculateStatus(user.presenceSession.lastSeenAt),
      statusMessage: user.presenceSession.statusMessage,
      currentProject: null, // Will be enriched
      currentTask: null,
    } : null,
    activities: activityLogs.filter(a => a.userId === user.id),
  }));
}

private calculateStatus(lastSeenAt: Date): PresenceStatus {
  const elapsed = Date.now() - lastSeenAt.getTime();
  if (elapsed < this.ONLINE_THRESHOLD) return PresenceStatus.Online;
  if (elapsed < this.AWAY_THRESHOLD) return PresenceStatus.Away;
  return PresenceStatus.Offline;
}
```

7. Add `getTaskTimeBreakdown` method for ACTV-04:
```typescript
async getTaskTimeBreakdown(
  userId: string,
  startDate: Date,
  endDate: Date,
) {
  const logs = await this.prisma.activityLog.findMany({
    where: {
      userId,
      startedAt: { gte: startDate, lte: endDate },
    },
    include: {
      project: { select: { id: true, name: true, code: true } },
      task: { select: { id: true, name: true, code: true } },
    },
    orderBy: { startedAt: 'asc' },
  });

  // Calculate duration for each log
  const breakdown = logs.map(log => {
    const endTime = log.endedAt || new Date();
    const durationMinutes = Math.round(
      (endTime.getTime() - log.startedAt.getTime()) / 60000
    );

    return {
      id: log.id,
      project: log.project,
      task: log.task,
      startedAt: log.startedAt,
      endedAt: log.endedAt,
      durationMinutes,
    };
  });

  // Aggregate by project/task
  const byProject = new Map<string, { project: any; totalMinutes: number; tasks: Map<string, number> }>();

  for (const item of breakdown) {
    if (!item.project) continue;

    const existing = byProject.get(item.project.id) || {
      project: item.project,
      totalMinutes: 0,
      tasks: new Map(),
    };

    existing.totalMinutes += item.durationMinutes;

    if (item.task) {
      const taskMinutes = existing.tasks.get(item.task.id) || 0;
      existing.tasks.set(item.task.id, taskMinutes + item.durationMinutes);
    }

    byProject.set(item.project.id, existing);
  }

  return {
    detailed: breakdown,
    summary: Array.from(byProject.values()).map(p => ({
      project: p.project,
      totalMinutes: p.totalMinutes,
      tasks: Array.from(p.tasks.entries()).map(([taskId, minutes]) => ({
        taskId,
        minutes,
      })),
    })),
  };
}
```

Import PresenceStatus from @prisma/client at the top of the file if not already imported.
  </action>
  <verify>
Run `cd apps/api && npm run build` - should compile without errors.
Verify the service file has all 7 methods: updatePresence, setActivity, postStatusUpdate, clearStatus, getAvailabilityList (enhanced), getTeamActivity, getTaskTimeBreakdown.
  </verify>
  <done>
PresenceService has GPS capture in updatePresence.
setActivity method creates ActivityLog entries.
postStatusUpdate/clearStatus methods manage status messages.
getAvailabilityList supports status and department filters.
getTeamActivity returns team activities for managers.
getTaskTimeBreakdown returns time spent per project/task.
  </done>
</task>

<task type="auto">
  <name>Task 4: Add new controller endpoints</name>
  <files>apps/api/src/presence/presence.controller.ts</files>
  <action>
Enhance the PresenceController with new endpoints:

```typescript
import { Controller, Get, Post, Delete, Body, Query, UseGuards } from '@nestjs/common';
import { ApiTags, ApiBearerAuth, ApiOperation, ApiQuery } from '@nestjs/swagger';
import { PresenceStatus, UserRole } from '@prisma/client';
import { PresenceService } from './presence.service';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { RolesGuard } from '../auth/guards/roles.guard';
import { Roles } from '../auth/decorators/roles.decorator';
import { CurrentUser } from '../auth/decorators/current-user.decorator';
import { SetActivityDto, PostStatusDto, UpdatePresenceDto } from './dto';

@ApiTags('Presence')
@ApiBearerAuth()
@UseGuards(JwtAuthGuard)
@Controller('presence')
export class PresenceController {
  constructor(private readonly presenceService: PresenceService) {}

  @Get('list')
  @ApiOperation({ summary: 'Get team availability list with optional filters' })
  @ApiQuery({ name: 'status', required: false, enum: PresenceStatus })
  @ApiQuery({ name: 'department', required: false, type: String })
  async getList(
    @CurrentUser() user: any,
    @Query('status') status?: PresenceStatus,
    @Query('department') department?: string,
  ) {
    const users = await this.presenceService.getAvailabilityList(
      user.companyId,
      { status, department },
    );
    return { success: true, data: { users } };
  }

  @Post('heartbeat')
  @ApiOperation({ summary: 'Send presence heartbeat with optional GPS' })
  async heartbeat(
    @CurrentUser() user: any,
    @Body() body: UpdatePresenceDto,
  ) {
    await this.presenceService.updatePresence(user.id, body);
    return { success: true };
  }

  @Post('activity')
  @ApiOperation({ summary: 'Set current activity (project/task)' })
  async setActivity(
    @CurrentUser() user: any,
    @Body() body: SetActivityDto,
  ) {
    const session = await this.presenceService.setActivity(
      user.id,
      body.projectId,
      body.taskId,
    );
    return { success: true, data: { session } };
  }

  @Post('status')
  @ApiOperation({ summary: 'Post a status update message' })
  async postStatus(
    @CurrentUser() user: any,
    @Body() body: PostStatusDto,
  ) {
    const session = await this.presenceService.postStatusUpdate(user.id, body.message);
    return { success: true, data: { session } };
  }

  @Delete('status')
  @ApiOperation({ summary: 'Clear current status message' })
  async clearStatus(@CurrentUser() user: any) {
    await this.presenceService.clearStatus(user.id);
    return { success: true };
  }

  @Get('team-activity')
  @UseGuards(RolesGuard)
  @Roles(UserRole.Manager, UserRole.HR, UserRole.SuperAdmin)
  @ApiOperation({ summary: 'Get team activity (manager/HR/admin view)' })
  @ApiQuery({ name: 'date', required: false, type: String, description: 'Date in YYYY-MM-DD format' })
  async getTeamActivity(
    @CurrentUser() user: any,
    @Query('date') date?: string,
  ) {
    const targetDate = date ? new Date(date) : new Date();
    const activities = await this.presenceService.getTeamActivity(
      user.id,
      user.role,
      user.companyId,
      targetDate,
    );
    return { success: true, data: { activities } };
  }

  @Get('task-breakdown')
  @ApiOperation({ summary: 'Get task time breakdown for current user' })
  @ApiQuery({ name: 'startDate', required: true, type: String })
  @ApiQuery({ name: 'endDate', required: true, type: String })
  async getTaskBreakdown(
    @CurrentUser() user: any,
    @Query('startDate') startDate: string,
    @Query('endDate') endDate: string,
  ) {
    const breakdown = await this.presenceService.getTaskTimeBreakdown(
      user.id,
      new Date(startDate),
      new Date(endDate),
    );
    return { success: true, data: breakdown };
  }
}
```

Update the imports at the top to include the new DTOs and guards.
  </action>
  <verify>
Run `cd apps/api && npm run build` - should compile without errors.
Run `npm run start:dev` and check Swagger at http://localhost:3001/api-docs - should show all new endpoints under Presence tag.
Test `GET /presence/list?status=Online` - should return filtered results (may be empty if no users online).
  </verify>
  <done>
Controller has 7 endpoints: GET /list, POST /heartbeat, POST /activity, POST /status, DELETE /status, GET /team-activity, GET /task-breakdown.
All endpoints have proper Swagger documentation.
Manager endpoints are protected with RolesGuard.
All endpoints compile and are accessible via Swagger.
  </done>
</task>

</tasks>

<verification>
1. Schema changes applied: `npx prisma validate` passes
2. API compiles: `cd apps/api && npm run build` succeeds
3. Swagger shows new endpoints: Visit http://localhost:3001/api-docs
4. Test endpoints:
   - POST /presence/activity with `{"projectId": "...", "taskId": "..."}` returns 200
   - POST /presence/status with `{"message": "Working on reports"}` returns 200
   - GET /presence/list?status=Online returns filtered list
   - GET /presence/team-activity (as Manager) returns team activities
   - GET /presence/task-breakdown?startDate=2026-01-24&endDate=2026-01-24 returns breakdown
</verification>

<success_criteria>
1. PresenceSession model has statusMessage, statusUpdatedAt, lastLatitude, lastLongitude fields
2. ActivityLog model exists with proper relations to User, Project, Task
3. PresenceService has methods for: updatePresence (with GPS), setActivity, postStatusUpdate, clearStatus, getAvailabilityList (with filters), getTeamActivity, getTaskTimeBreakdown
4. PresenceController has REST endpoints for all operations
5. All endpoints documented in Swagger
6. API compiles and starts without errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-presence-activity/05-01-SUMMARY.md`
</output>
