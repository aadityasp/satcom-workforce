---
phase: 05-presence-activity
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - apps/api/src/presence/presence.gateway.ts
  - apps/api/src/presence/presence.module.ts
autonomous: true

must_haves:
  truths:
    - "WebSocket heartbeat captures GPS coordinates"
    - "Activity changes are broadcast to connected clients"
    - "Status updates are broadcast in real-time"
    - "Stale sessions are automatically marked offline"
    - "User online/offline events are broadcast"
  artifacts:
    - path: "apps/api/src/presence/presence.gateway.ts"
      provides: "Enhanced WebSocket gateway with GPS capture and activity events"
      exports: ["PresenceGateway"]
    - path: "apps/api/src/presence/presence.module.ts"
      provides: "Module with ScheduleModule for cron jobs"
      exports: ["PresenceModule"]
  key_links:
    - from: "apps/api/src/presence/presence.gateway.ts"
      to: "apps/api/src/presence/presence.service.ts"
      via: "service injection"
      pattern: "this\\.presenceService\\."
    - from: "apps/api/src/presence/presence.gateway.ts"
      to: "socket.io server"
      via: "emit events"
      pattern: "this\\.server\\.emit"
---

<objective>
Enhance the PresenceGateway to support GPS capture in heartbeats, broadcast activity changes and status updates, and add scheduled cleanup of stale sessions.

Purpose: Enable real-time WebSocket communication for presence updates (PRES-05) with proper GPS capture (ACTV-06) and automatic stale session cleanup.

Output:
- Enhanced PresenceGateway with GPS in heartbeat, activity events, status events
- Scheduled cron job for stale session cleanup
- Real-time broadcast of presence changes to all connected clients
</objective>

<execution_context>
@/Users/adityaw/.claude/get-shit-done/workflows/execute-plan.md
@/Users/adityaw/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-presence-activity/05-RESEARCH.md
@.planning/phases/05-presence-activity/05-01-SUMMARY.md

# Existing gateway
@apps/api/src/presence/presence.gateway.ts
@apps/api/src/presence/presence.module.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance PresenceGateway with GPS and activity events</name>
  <files>apps/api/src/presence/presence.gateway.ts</files>
  <action>
Enhance the existing PresenceGateway with the following:

```typescript
/**
 * Presence Gateway - WebSocket handler for real-time presence
 *
 * Events emitted:
 * - user:online - When user connects
 * - user:offline - When user disconnects
 * - presence:update - Heartbeat with status, GPS, current activity
 * - activity:changed - When user changes current project/task
 * - status:updated - When user posts/clears status message
 */
import {
  WebSocketGateway,
  WebSocketServer,
  SubscribeMessage,
  OnGatewayConnection,
  OnGatewayDisconnect,
  ConnectedSocket,
  MessageBody,
} from '@nestjs/websockets';
import { Server, Socket } from 'socket.io';
import { JwtService } from '@nestjs/jwt';
import { Injectable, Logger } from '@nestjs/common';
import { Cron } from '@nestjs/schedule';
import { PresenceService } from './presence.service';
import { PrismaService } from '../prisma/prisma.service';
import { PresenceStatus } from '@prisma/client';

interface HeartbeatPayload {
  projectId?: string;
  taskId?: string;
  latitude?: number;
  longitude?: number;
}

interface SetActivityPayload {
  projectId: string;
  taskId?: string;
}

interface StatusPayload {
  message: string;
}

@Injectable()
@WebSocketGateway({
  cors: { origin: '*' },
  namespace: 'presence',
})
export class PresenceGateway implements OnGatewayConnection, OnGatewayDisconnect {
  @WebSocketServer()
  server: Server;

  private readonly logger = new Logger(PresenceGateway.name);
  private userSockets: Map<string, Set<string>> = new Map(); // userId -> Set<socketId> (multi-device)
  private socketUsers: Map<string, string> = new Map(); // socketId -> userId

  private readonly AWAY_THRESHOLD = 15 * 60 * 1000; // 15 minutes

  constructor(
    private presenceService: PresenceService,
    private prisma: PrismaService,
    private jwtService: JwtService,
  ) {}

  async handleConnection(client: Socket) {
    try {
      const token = client.handshake.auth.token;
      if (!token) {
        this.logger.warn(`Connection attempt without token: ${client.id}`);
        client.disconnect();
        return;
      }

      const payload = this.jwtService.verify(token);
      const userId = payload.sub;
      const companyId = payload.companyId;

      // Track multi-device connections
      const userSocketSet = this.userSockets.get(userId) || new Set();
      userSocketSet.add(client.id);
      this.userSockets.set(userId, userSocketSet);
      this.socketUsers.set(client.id, userId);

      // Join company room for targeted broadcasts
      client.join(`company:${companyId}`);

      // Update presence
      await this.presenceService.updatePresence(userId, {});

      // Broadcast online status (only if first connection for this user)
      if (userSocketSet.size === 1) {
        this.server.to(`company:${companyId}`).emit('user:online', {
          userId,
          timestamp: new Date().toISOString(),
        });
        this.logger.log(`User ${userId} connected (first device)`);
      } else {
        this.logger.log(`User ${userId} connected (additional device, total: ${userSocketSet.size})`);
      }
    } catch (error) {
      this.logger.warn(`Connection failed: ${error.message}`);
      client.disconnect();
    }
  }

  async handleDisconnect(client: Socket) {
    const userId = this.socketUsers.get(client.id);
    if (!userId) return;

    // Remove this socket from tracking
    this.socketUsers.delete(client.id);
    const userSocketSet = this.userSockets.get(userId);

    if (userSocketSet) {
      userSocketSet.delete(client.id);

      // Only mark offline if no more connections for this user
      if (userSocketSet.size === 0) {
        this.userSockets.delete(userId);
        await this.presenceService.setOffline(userId);

        // Get company from any room the client was in
        const rooms = Array.from(client.rooms);
        const companyRoom = rooms.find(r => r.startsWith('company:'));
        if (companyRoom) {
          this.server.to(companyRoom).emit('user:offline', {
            userId,
            timestamp: new Date().toISOString(),
          });
        }
        this.logger.log(`User ${userId} disconnected (last device)`);
      } else {
        this.logger.log(`User ${userId} disconnected (${userSocketSet.size} devices remaining)`);
      }
    }
  }

  @SubscribeMessage('presence:heartbeat')
  async handleHeartbeat(
    @ConnectedSocket() client: Socket,
    @MessageBody() data: HeartbeatPayload,
  ) {
    const userId = this.socketUsers.get(client.id);
    if (!userId) return;

    try {
      const session = await this.presenceService.updatePresence(userId, {
        projectId: data.projectId,
        taskId: data.taskId,
        latitude: data.latitude,
        longitude: data.longitude,
      });

      // Get company room
      const rooms = Array.from(client.rooms);
      const companyRoom = rooms.find(r => r.startsWith('company:'));

      if (companyRoom) {
        this.server.to(companyRoom).emit('presence:update', {
          userId,
          status: session.status,
          lastSeenAt: session.lastSeenAt,
          currentProjectId: session.currentProjectId,
          currentTaskId: session.currentTaskId,
          lastLatitude: session.lastLatitude ? Number(session.lastLatitude) : null,
          lastLongitude: session.lastLongitude ? Number(session.lastLongitude) : null,
        });
      }

      return { success: true };
    } catch (error) {
      this.logger.error(`Heartbeat failed for ${userId}: ${error.message}`);
      return { success: false, error: error.message };
    }
  }

  @SubscribeMessage('activity:set')
  async handleSetActivity(
    @ConnectedSocket() client: Socket,
    @MessageBody() data: SetActivityPayload,
  ) {
    const userId = this.socketUsers.get(client.id);
    if (!userId) return;

    try {
      const session = await this.presenceService.setActivity(
        userId,
        data.projectId,
        data.taskId,
      );

      // Get company room
      const rooms = Array.from(client.rooms);
      const companyRoom = rooms.find(r => r.startsWith('company:'));

      if (companyRoom) {
        this.server.to(companyRoom).emit('activity:changed', {
          userId,
          projectId: session.currentProjectId,
          taskId: session.currentTaskId,
          timestamp: new Date().toISOString(),
        });
      }

      return { success: true, session };
    } catch (error) {
      this.logger.error(`Set activity failed for ${userId}: ${error.message}`);
      return { success: false, error: error.message };
    }
  }

  @SubscribeMessage('status:post')
  async handlePostStatus(
    @ConnectedSocket() client: Socket,
    @MessageBody() data: StatusPayload,
  ) {
    const userId = this.socketUsers.get(client.id);
    if (!userId) return;

    try {
      const session = await this.presenceService.postStatusUpdate(userId, data.message);

      // Get company room
      const rooms = Array.from(client.rooms);
      const companyRoom = rooms.find(r => r.startsWith('company:'));

      if (companyRoom) {
        this.server.to(companyRoom).emit('status:updated', {
          userId,
          statusMessage: session.statusMessage,
          statusUpdatedAt: session.statusUpdatedAt,
        });
      }

      return { success: true, session };
    } catch (error) {
      this.logger.error(`Post status failed for ${userId}: ${error.message}`);
      return { success: false, error: error.message };
    }
  }

  @SubscribeMessage('status:clear')
  async handleClearStatus(@ConnectedSocket() client: Socket) {
    const userId = this.socketUsers.get(client.id);
    if (!userId) return;

    try {
      await this.presenceService.clearStatus(userId);

      // Get company room
      const rooms = Array.from(client.rooms);
      const companyRoom = rooms.find(r => r.startsWith('company:'));

      if (companyRoom) {
        this.server.to(companyRoom).emit('status:updated', {
          userId,
          statusMessage: null,
          statusUpdatedAt: null,
        });
      }

      return { success: true };
    } catch (error) {
      this.logger.error(`Clear status failed for ${userId}: ${error.message}`);
      return { success: false, error: error.message };
    }
  }

  /**
   * Cron job to clean up stale sessions
   * Runs every 5 minutes to mark users as offline if no heartbeat in 15 minutes
   */
  @Cron('*/5 * * * *')
  async cleanupStaleSessions() {
    const threshold = new Date(Date.now() - this.AWAY_THRESHOLD);

    try {
      const stale = await this.prisma.presenceSession.findMany({
        where: {
          lastSeenAt: { lt: threshold },
          status: { not: PresenceStatus.Offline },
        },
        include: {
          user: { select: { companyId: true } },
        },
      });

      if (stale.length === 0) return;

      // Update all stale sessions to Offline
      await this.prisma.presenceSession.updateMany({
        where: {
          id: { in: stale.map(s => s.id) },
        },
        data: { status: PresenceStatus.Offline },
      });

      // Broadcast offline events per company
      const byCompany = new Map<string, string[]>();
      for (const session of stale) {
        const companyId = session.user.companyId;
        const users = byCompany.get(companyId) || [];
        users.push(session.userId);
        byCompany.set(companyId, users);
      }

      for (const [companyId, userIds] of byCompany) {
        for (const userId of userIds) {
          this.server.to(`company:${companyId}`).emit('user:offline', {
            userId,
            reason: 'stale_session',
            timestamp: new Date().toISOString(),
          });
        }
      }

      this.logger.log(`Cleaned up ${stale.length} stale presence sessions`);
    } catch (error) {
      this.logger.error(`Stale session cleanup failed: ${error.message}`);
    }
  }
}
```

Key changes:
1. Multi-device support with userSockets Map<string, Set<string>>
2. Company rooms for targeted broadcasts
3. GPS capture in heartbeat
4. New events: activity:set, status:post, status:clear
5. Cron job for stale session cleanup
6. Proper logging
  </action>
  <verify>
Run `cd apps/api && npm run build` - should compile without errors.
Check that the gateway has @Cron decorator import from @nestjs/schedule.
Run `npm run start:dev` and check logs for "PresenceGateway" initialization.
  </verify>
  <done>
PresenceGateway handles multi-device connections.
Heartbeat accepts and stores GPS coordinates.
Activity changes are broadcast via 'activity:changed' event.
Status updates are broadcast via 'status:updated' event.
Cron job runs every 5 minutes to clean stale sessions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update PresenceModule for scheduling</name>
  <files>apps/api/src/presence/presence.module.ts</files>
  <action>
Update the PresenceModule to include ScheduleModule for cron jobs:

```typescript
import { Module } from '@nestjs/common';
import { ScheduleModule } from '@nestjs/schedule';
import { JwtModule } from '@nestjs/jwt';
import { PresenceGateway } from './presence.gateway';
import { PresenceService } from './presence.service';
import { PresenceController } from './presence.controller';
import { PrismaModule } from '../prisma/prisma.module';

@Module({
  imports: [
    PrismaModule,
    ScheduleModule.forRoot(),
    JwtModule.register({
      secret: process.env.JWT_ACCESS_SECRET || 'access-secret-key',
      signOptions: { expiresIn: '15m' },
    }),
  ],
  controllers: [PresenceController],
  providers: [PresenceGateway, PresenceService],
  exports: [PresenceService],
})
export class PresenceModule {}
```

Note: If ScheduleModule.forRoot() is already called in AppModule, remove it from here and just ensure @nestjs/schedule is installed. Check app.module.ts first.

If app.module.ts already has ScheduleModule.forRoot(), the presence.module.ts should NOT call it again. Just ensure the Cron decorator works (it will if ScheduleModule is in app.module).
  </action>
  <verify>
Check if ScheduleModule.forRoot() is in app.module.ts or needs to be in presence.module.ts.
Run `cd apps/api && npm run build` - should compile without errors.
Run `npm run start:dev` - check logs show "Cron" or scheduling messages after 5 minutes (or manually trigger cleanup).
  </verify>
  <done>
PresenceModule properly configured with scheduling support.
Cron job for stale session cleanup is registered and running.
Module compiles and starts without errors.
  </done>
</task>

</tasks>

<verification>
1. API compiles: `cd apps/api && npm run build` succeeds
2. Gateway handles connections: Start API, connect via Socket.IO client to /presence namespace with valid token
3. Heartbeat with GPS: Send `presence:heartbeat` event with `{latitude: 12.9, longitude: 77.6}`, verify stored in DB
4. Activity broadcast: Send `activity:set` event, verify `activity:changed` event received by other connected clients
5. Status broadcast: Send `status:post` event, verify `status:updated` event received
6. Stale cleanup: Check logs for "Cleaned up X stale presence sessions" after 5 minutes (or verify DB)
</verification>

<success_criteria>
1. PresenceGateway handles multi-device connections (same user on multiple devices)
2. Heartbeat captures GPS coordinates and stores in PresenceSession
3. activity:set event creates ActivityLog and broadcasts activity:changed
4. status:post/status:clear events update statusMessage and broadcast status:updated
5. Cron job runs every 5 minutes to mark stale sessions as Offline
6. All events are scoped to company rooms (not broadcast globally)
7. API compiles and starts without errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-presence-activity/05-02-SUMMARY.md`
</output>
