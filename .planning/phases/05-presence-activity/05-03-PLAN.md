---
phase: 05-presence-activity
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - apps/web/src/store/presence.ts
  - apps/web/src/hooks/usePresence.ts
  - apps/web/src/hooks/index.ts
  - apps/web/src/components/presence/PresenceIndicator.tsx
  - apps/web/src/components/presence/TeamListCard.tsx
  - apps/web/src/components/presence/index.ts
  - apps/web/src/app/team/page.tsx
autonomous: true

must_haves:
  truths:
    - "Team list shows real user data from API"
    - "Presence indicators show Online/Away/Offline status"
    - "Status updates in real-time without page refresh"
    - "User can see team member's current activity"
    - "Team list can be filtered by status and department"
  artifacts:
    - path: "apps/web/src/store/presence.ts"
      provides: "Zustand store for presence state with Socket.IO"
      exports: ["usePresenceStore"]
    - path: "apps/web/src/hooks/usePresence.ts"
      provides: "Hook for presence operations"
      exports: ["usePresence"]
    - path: "apps/web/src/components/presence/PresenceIndicator.tsx"
      provides: "Status dot component"
      exports: ["PresenceIndicator"]
    - path: "apps/web/src/app/team/page.tsx"
      provides: "Team list page with real-time presence"
      min_lines: 100
  key_links:
    - from: "apps/web/src/app/team/page.tsx"
      to: "apps/web/src/hooks/usePresence.ts"
      via: "hook usage"
      pattern: "usePresence\\(\\)"
    - from: "apps/web/src/store/presence.ts"
      to: "socket.io-client"
      via: "WebSocket connection"
      pattern: "io\\("
    - from: "apps/web/src/hooks/usePresence.ts"
      to: "/api/presence"
      via: "REST API calls"
      pattern: "api\\.get.*presence"
---

<objective>
Build frontend presence infrastructure with Zustand store, Socket.IO integration, and replace the hardcoded team page with real-time data.

Purpose: Enable users to see real-time team availability (PRES-02), presence indicators (PRES-01), and current work mode (PRES-04) with WebSocket updates (PRES-05).

Output:
- Zustand presence store with Socket.IO connection management
- usePresence hook for components
- PresenceIndicator component for status dots
- TeamListCard component for team member display
- Replaced team page with real data and filtering
</objective>

<execution_context>
@/Users/adityaw/.claude/get-shit-done/workflows/execute-plan.md
@/Users/adityaw/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-presence-activity/05-RESEARCH.md
@.planning/phases/05-presence-activity/05-01-SUMMARY.md

# Existing patterns
@apps/web/src/store/auth.ts
@apps/web/src/hooks/useAttendance.ts
@apps/web/src/app/team/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Zustand presence store with Socket.IO</name>
  <files>apps/web/src/store/presence.ts</files>
  <action>
Create the presence store following the auth.ts pattern but with Socket.IO integration:

```typescript
/**
 * Presence Store
 *
 * Manages real-time presence state using Zustand with Socket.IO integration.
 * Handles WebSocket connection, team member state, and real-time updates.
 */

'use client';

import { create } from 'zustand';
import { io, Socket } from 'socket.io-client';

// Types
export type PresenceStatus = 'Online' | 'Away' | 'Offline' | 'Busy';

export interface TeamMember {
  userId: string;
  status: PresenceStatus;
  lastSeenAt: string;
  currentWorkMode?: string;
  statusMessage?: string;
  statusUpdatedAt?: string;
  currentProject?: {
    id: string;
    name: string;
    code: string;
  } | null;
  currentTask?: {
    id: string;
    name: string;
    code: string;
  } | null;
  profile?: {
    firstName: string;
    lastName: string;
    designation: string;
    department?: string;
    avatarUrl?: string;
  } | null;
}

interface PresenceState {
  // Connection state
  socket: Socket | null;
  isConnected: boolean;
  connectionError: string | null;

  // Team data
  teamMembers: TeamMember[];
  isLoading: boolean;

  // Filters
  statusFilter: PresenceStatus | null;
  departmentFilter: string | null;

  // Actions
  connect: (token: string) => void;
  disconnect: () => void;
  setTeamMembers: (members: TeamMember[]) => void;
  setStatusFilter: (status: PresenceStatus | null) => void;
  setDepartmentFilter: (department: string | null) => void;

  // Socket actions
  sendHeartbeat: (data?: { projectId?: string; taskId?: string; latitude?: number; longitude?: number }) => void;
  setActivity: (projectId: string, taskId?: string) => void;
  postStatus: (message: string) => void;
  clearStatus: () => void;
}

const API_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001';

export const usePresenceStore = create<PresenceState>((set, get) => ({
  // Initial state
  socket: null,
  isConnected: false,
  connectionError: null,
  teamMembers: [],
  isLoading: false,
  statusFilter: null,
  departmentFilter: null,

  connect: (token: string) => {
    const existingSocket = get().socket;
    if (existingSocket?.connected) {
      return; // Already connected
    }

    // Disconnect existing socket if any
    existingSocket?.disconnect();

    const socket = io(`${API_URL}/presence`, {
      auth: { token },
      autoConnect: true,
      reconnection: true,
      reconnectionAttempts: 5,
      reconnectionDelay: 1000,
      reconnectionDelayMax: 5000,
    });

    // Connection events
    socket.on('connect', () => {
      console.log('[Presence] Connected to server');
      set({ isConnected: true, connectionError: null });
    });

    socket.on('disconnect', (reason) => {
      console.log('[Presence] Disconnected:', reason);
      set({ isConnected: false });
    });

    socket.on('connect_error', (error) => {
      console.error('[Presence] Connection error:', error.message);
      set({ connectionError: error.message, isConnected: false });
    });

    // Presence events
    socket.on('user:online', (data: { userId: string; timestamp: string }) => {
      set((state) => ({
        teamMembers: state.teamMembers.map((m) =>
          m.userId === data.userId
            ? { ...m, status: 'Online' as PresenceStatus, lastSeenAt: data.timestamp }
            : m
        ),
      }));
    });

    socket.on('user:offline', (data: { userId: string; timestamp: string }) => {
      set((state) => ({
        teamMembers: state.teamMembers.map((m) =>
          m.userId === data.userId
            ? { ...m, status: 'Offline' as PresenceStatus, lastSeenAt: data.timestamp }
            : m
        ),
      }));
    });

    socket.on('presence:update', (data: {
      userId: string;
      status: PresenceStatus;
      lastSeenAt: string;
      currentProjectId?: string;
      currentTaskId?: string;
    }) => {
      set((state) => ({
        teamMembers: state.teamMembers.map((m) =>
          m.userId === data.userId
            ? {
                ...m,
                status: data.status,
                lastSeenAt: data.lastSeenAt,
              }
            : m
        ),
      }));
    });

    socket.on('activity:changed', (data: {
      userId: string;
      projectId?: string;
      taskId?: string;
      timestamp: string;
    }) => {
      // Will need to refetch to get project/task names, or store can be updated with IDs
      set((state) => ({
        teamMembers: state.teamMembers.map((m) =>
          m.userId === data.userId
            ? {
                ...m,
                currentProject: data.projectId ? { id: data.projectId, name: '', code: '' } : null,
                currentTask: data.taskId ? { id: data.taskId, name: '', code: '' } : null,
              }
            : m
        ),
      }));
    });

    socket.on('status:updated', (data: {
      userId: string;
      statusMessage: string | null;
      statusUpdatedAt: string | null;
    }) => {
      set((state) => ({
        teamMembers: state.teamMembers.map((m) =>
          m.userId === data.userId
            ? {
                ...m,
                statusMessage: data.statusMessage || undefined,
                statusUpdatedAt: data.statusUpdatedAt || undefined,
              }
            : m
        ),
      }));
    });

    set({ socket });
  },

  disconnect: () => {
    const { socket } = get();
    if (socket) {
      socket.disconnect();
      set({ socket: null, isConnected: false });
    }
  },

  setTeamMembers: (members: TeamMember[]) => {
    set({ teamMembers: members });
  },

  setStatusFilter: (status: PresenceStatus | null) => {
    set({ statusFilter: status });
  },

  setDepartmentFilter: (department: string | null) => {
    set({ departmentFilter: department });
  },

  // Socket emit actions
  sendHeartbeat: (data = {}) => {
    const { socket, isConnected } = get();
    if (socket && isConnected) {
      socket.emit('presence:heartbeat', data);
    }
  },

  setActivity: (projectId: string, taskId?: string) => {
    const { socket, isConnected } = get();
    if (socket && isConnected) {
      socket.emit('activity:set', { projectId, taskId });
    }
  },

  postStatus: (message: string) => {
    const { socket, isConnected } = get();
    if (socket && isConnected) {
      socket.emit('status:post', { message });
    }
  },

  clearStatus: () => {
    const { socket, isConnected } = get();
    if (socket && isConnected) {
      socket.emit('status:clear', {});
    }
  },
}));

// Selector for filtered team members
export const useFilteredTeamMembers = () => {
  return usePresenceStore((state) => {
    let members = state.teamMembers;

    if (state.statusFilter) {
      members = members.filter((m) => m.status === state.statusFilter);
    }

    if (state.departmentFilter) {
      members = members.filter((m) => m.profile?.department === state.departmentFilter);
    }

    return members;
  });
};

// Selector for unique departments
export const useUniqueDepartments = () => {
  return usePresenceStore((state) => {
    const departments = new Set<string>();
    state.teamMembers.forEach((m) => {
      if (m.profile?.department) {
        departments.add(m.profile.department);
      }
    });
    return Array.from(departments).sort();
  });
};
```
  </action>
  <verify>
Run `cd apps/web && npm run build` - should compile without TypeScript errors.
Check that the file exports usePresenceStore, useFilteredTeamMembers, useUniqueDepartments.
  </verify>
  <done>
Zustand presence store created with Socket.IO integration.
Store handles connection, team members, filters, and socket events.
Selectors exported for filtered members and unique departments.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create usePresence hook and presence components</name>
  <files>
apps/web/src/hooks/usePresence.ts
apps/web/src/hooks/index.ts
apps/web/src/components/presence/PresenceIndicator.tsx
apps/web/src/components/presence/TeamListCard.tsx
apps/web/src/components/presence/index.ts
  </files>
  <action>
Create the usePresence hook (apps/web/src/hooks/usePresence.ts):

```typescript
'use client';

/**
 * usePresence Hook
 *
 * Manages presence connection and provides team member data.
 * Handles initial data fetch and WebSocket lifecycle.
 */

import { useEffect, useCallback, useRef } from 'react';
import { usePresenceStore, useFilteredTeamMembers, useUniqueDepartments, TeamMember } from '@/store/presence';
import { useAuthStore } from '@/store/auth';
import { api } from '@/lib/api';

interface UsePresenceReturn {
  // Connection state
  isConnected: boolean;
  connectionError: string | null;

  // Team data
  teamMembers: TeamMember[];
  filteredMembers: TeamMember[];
  departments: string[];
  isLoading: boolean;

  // Filters
  statusFilter: string | null;
  departmentFilter: string | null;
  setStatusFilter: (status: string | null) => void;
  setDepartmentFilter: (department: string | null) => void;

  // Actions
  refresh: () => Promise<void>;
  setActivity: (projectId: string, taskId?: string) => void;
  postStatus: (message: string) => void;
  clearStatus: () => void;
}

export function usePresence(): UsePresenceReturn {
  const { accessToken } = useAuthStore();
  const {
    socket,
    isConnected,
    connectionError,
    teamMembers,
    isLoading,
    statusFilter,
    departmentFilter,
    connect,
    disconnect,
    setTeamMembers,
    setStatusFilter,
    setDepartmentFilter,
    setActivity,
    postStatus,
    clearStatus,
  } = usePresenceStore();

  const filteredMembers = useFilteredTeamMembers();
  const departments = useUniqueDepartments();
  const heartbeatInterval = useRef<NodeJS.Timeout | null>(null);

  // Fetch initial team list
  const refresh = useCallback(async () => {
    try {
      usePresenceStore.setState({ isLoading: true });
      const params = new URLSearchParams();
      if (statusFilter) params.append('status', statusFilter);
      if (departmentFilter) params.append('department', departmentFilter);

      const response = await api.get<{ users: TeamMember[] }>(
        `/presence/list${params.toString() ? `?${params.toString()}` : ''}`
      );

      if (response.success && response.data) {
        setTeamMembers(response.data.users);
      }
    } catch (error) {
      console.error('[usePresence] Failed to fetch team list:', error);
    } finally {
      usePresenceStore.setState({ isLoading: false });
    }
  }, [statusFilter, departmentFilter, setTeamMembers]);

  // Connect to WebSocket when authenticated
  useEffect(() => {
    if (accessToken && !socket) {
      connect(accessToken);
    }

    return () => {
      // Don't disconnect on unmount - let store persist
      // disconnect() would be called here if we want to cleanup
    };
  }, [accessToken, socket, connect]);

  // Fetch initial data when connected
  useEffect(() => {
    if (isConnected) {
      refresh();
    }
  }, [isConnected, refresh]);

  // Heartbeat every 30 seconds (with GPS if available)
  useEffect(() => {
    if (!isConnected) return;

    const sendHeartbeat = () => {
      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
          (position) => {
            usePresenceStore.getState().sendHeartbeat({
              latitude: position.coords.latitude,
              longitude: position.coords.longitude,
            });
          },
          () => {
            // GPS not available, send heartbeat without location
            usePresenceStore.getState().sendHeartbeat();
          },
          { timeout: 5000, maximumAge: 60000 }
        );
      } else {
        usePresenceStore.getState().sendHeartbeat();
      }
    };

    // Send initial heartbeat
    sendHeartbeat();

    // Set up interval
    heartbeatInterval.current = setInterval(sendHeartbeat, 30000);

    return () => {
      if (heartbeatInterval.current) {
        clearInterval(heartbeatInterval.current);
      }
    };
  }, [isConnected]);

  // Refetch when filters change
  useEffect(() => {
    if (isConnected) {
      refresh();
    }
  }, [statusFilter, departmentFilter]);

  return {
    isConnected,
    connectionError,
    teamMembers,
    filteredMembers,
    departments,
    isLoading,
    statusFilter,
    departmentFilter,
    setStatusFilter: (status) => setStatusFilter(status as any),
    setDepartmentFilter,
    refresh,
    setActivity,
    postStatus,
    clearStatus,
  };
}
```

Update hooks index (apps/web/src/hooks/index.ts):
```typescript
export * from './useAttendance';
export * from './useTimesheets';
export * from './useLocations';
export * from './useCheckInLocations';
export * from './usePresence';
```

Create PresenceIndicator component (apps/web/src/components/presence/PresenceIndicator.tsx):

```typescript
'use client';

import { PresenceStatus } from '@/store/presence';

interface PresenceIndicatorProps {
  status: PresenceStatus;
  size?: 'sm' | 'md' | 'lg';
  showLabel?: boolean;
  pulse?: boolean;
}

const statusColors: Record<PresenceStatus, string> = {
  Online: 'bg-success',
  Away: 'bg-warning',
  Offline: 'bg-silver-400',
  Busy: 'bg-error',
};

const statusLabels: Record<PresenceStatus, string> = {
  Online: 'Online',
  Away: 'Away',
  Offline: 'Offline',
  Busy: 'Busy',
};

const sizes = {
  sm: 'w-2 h-2',
  md: 'w-3 h-3',
  lg: 'w-4 h-4',
};

export function PresenceIndicator({
  status,
  size = 'md',
  showLabel = false,
  pulse = false,
}: PresenceIndicatorProps) {
  return (
    <div className="flex items-center gap-1.5">
      <div className="relative">
        <div
          className={`${sizes[size]} ${statusColors[status]} rounded-full border-2 border-white`}
          title={statusLabels[status]}
        />
        {pulse && status === 'Online' && (
          <div
            className={`absolute inset-0 ${sizes[size]} ${statusColors[status]} rounded-full animate-ping opacity-75`}
          />
        )}
      </div>
      {showLabel && (
        <span className="text-xs text-silver-600">{statusLabels[status]}</span>
      )}
    </div>
  );
}
```

Create TeamListCard component (apps/web/src/components/presence/TeamListCard.tsx):

```typescript
'use client';

import { useRouter } from 'next/navigation';
import { MessageSquare, Phone, Mail } from 'lucide-react';
import { TeamMember } from '@/store/presence';
import { PresenceIndicator } from './PresenceIndicator';
import { formatDistanceToNow } from 'date-fns';

interface TeamListCardProps {
  member: TeamMember;
}

export function TeamListCard({ member }: TeamListCardProps) {
  const router = useRouter();

  const initials = member.profile
    ? `${member.profile.firstName[0]}${member.profile.lastName[0]}`
    : '??';

  const fullName = member.profile
    ? `${member.profile.firstName} ${member.profile.lastName}`
    : 'Unknown User';

  const lastSeen = member.lastSeenAt
    ? formatDistanceToNow(new Date(member.lastSeenAt), { addSuffix: true })
    : 'Never';

  return (
    <div className="bg-white rounded-xl border border-silver-200 p-4 hover:shadow-md transition-shadow">
      <div className="flex items-start gap-4">
        {/* Avatar with presence indicator */}
        <div className="relative">
          <div className="w-12 h-12 bg-blue-100 rounded-full flex items-center justify-center">
            {member.profile?.avatarUrl ? (
              <img
                src={member.profile.avatarUrl}
                alt={fullName}
                className="w-12 h-12 rounded-full object-cover"
              />
            ) : (
              <span className="text-blue-600 font-medium">{initials}</span>
            )}
          </div>
          <div className="absolute -bottom-0.5 -right-0.5">
            <PresenceIndicator status={member.status} size="md" />
          </div>
        </div>

        {/* Info */}
        <div className="flex-1 min-w-0">
          <h3 className="font-medium text-navy-900 truncate">{fullName}</h3>
          <p className="text-sm text-silver-500 truncate">
            {member.profile?.designation || 'Employee'}
          </p>
          <p className="text-xs text-silver-400 mt-1">
            {member.profile?.department || 'No department'}
            {member.currentWorkMode && ` â€¢ ${member.currentWorkMode}`}
          </p>

          {/* Status message */}
          {member.statusMessage && (
            <p className="text-xs text-blue-600 mt-1 truncate italic">
              "{member.statusMessage}"
            </p>
          )}

          {/* Current activity */}
          {member.currentProject && (
            <p className="text-xs text-silver-500 mt-1 truncate">
              Working on: {member.currentProject.name}
              {member.currentTask && ` / ${member.currentTask.name}`}
            </p>
          )}

          {/* Last seen (for offline users) */}
          {member.status === 'Offline' && (
            <p className="text-xs text-silver-400 mt-1">
              Last seen {lastSeen}
            </p>
          )}
        </div>
      </div>

      {/* Actions */}
      <div className="mt-4 flex gap-2">
        <button
          onClick={() => router.push(`/chat?user=${member.userId}`)}
          className="flex-1 btn-secondary text-sm py-1.5 flex items-center justify-center gap-2"
        >
          <MessageSquare size={14} />
          Message
        </button>
        <button className="p-2 border border-silver-200 rounded-lg hover:bg-silver-50">
          <Phone size={14} className="text-silver-500" />
        </button>
        <button className="p-2 border border-silver-200 rounded-lg hover:bg-silver-50">
          <Mail size={14} className="text-silver-500" />
        </button>
      </div>
    </div>
  );
}
```

Create presence components index (apps/web/src/components/presence/index.ts):

```typescript
export * from './PresenceIndicator';
export * from './TeamListCard';
```
  </action>
  <verify>
Run `cd apps/web && npm run build` - should compile without errors.
Check that all files exist in their respective directories.
Verify usePresence is exported from hooks/index.ts.
  </verify>
  <done>
usePresence hook created with auto-connect, heartbeat, and filter management.
PresenceIndicator component shows colored status dots.
TeamListCard component displays team member info with presence.
All components exported from index files.
  </done>
</task>

<task type="auto">
  <name>Task 3: Replace team page with real-time data</name>
  <files>apps/web/src/app/team/page.tsx</files>
  <action>
Replace the hardcoded team page with real data and filtering:

```typescript
'use client';

import { useRouter } from 'next/navigation';
import { ArrowLeft, Users, Filter, RefreshCw } from 'lucide-react';
import { usePresence } from '@/hooks/usePresence';
import { TeamListCard, PresenceIndicator } from '@/components/presence';
import { PresenceStatus } from '@/store/presence';

const statusOptions: { value: PresenceStatus | null; label: string }[] = [
  { value: null, label: 'All Statuses' },
  { value: 'Online', label: 'Online' },
  { value: 'Away', label: 'Away' },
  { value: 'Offline', label: 'Offline' },
];

export default function TeamPage() {
  const router = useRouter();
  const {
    isConnected,
    filteredMembers,
    departments,
    isLoading,
    statusFilter,
    departmentFilter,
    setStatusFilter,
    setDepartmentFilter,
    refresh,
  } = usePresence();

  // Count by status
  const onlineCount = filteredMembers.filter((m) => m.status === 'Online').length;
  const awayCount = filteredMembers.filter((m) => m.status === 'Away').length;
  const offlineCount = filteredMembers.filter((m) => m.status === 'Offline').length;

  return (
    <div className="min-h-screen bg-silver-50">
      {/* Header */}
      <header className="bg-white border-b border-silver-200 sticky top-0 z-50">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="flex items-center h-16 gap-4">
            <button
              onClick={() => router.back()}
              className="p-2 hover:bg-silver-100 rounded-lg"
            >
              <ArrowLeft size={20} />
            </button>
            <div className="flex items-center gap-2">
              <Users size={20} className="text-navy-600" />
              <h1 className="text-lg font-semibold text-navy-900">Team</h1>
            </div>

            {/* Connection indicator */}
            <div className="ml-auto flex items-center gap-2">
              {isConnected ? (
                <span className="flex items-center gap-1 text-xs text-success">
                  <span className="w-2 h-2 bg-success rounded-full animate-pulse" />
                  Live
                </span>
              ) : (
                <span className="flex items-center gap-1 text-xs text-silver-400">
                  <span className="w-2 h-2 bg-silver-400 rounded-full" />
                  Connecting...
                </span>
              )}

              <button
                onClick={refresh}
                disabled={isLoading}
                className="p-2 hover:bg-silver-100 rounded-lg disabled:opacity-50"
                title="Refresh"
              >
                <RefreshCw
                  size={16}
                  className={`text-silver-500 ${isLoading ? 'animate-spin' : ''}`}
                />
              </button>
            </div>
          </div>
        </div>
      </header>

      <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6">
        {/* Status summary */}
        <div className="flex gap-4 mb-6">
          <div className="flex items-center gap-2 bg-white px-4 py-2 rounded-lg border border-silver-200">
            <PresenceIndicator status="Online" size="sm" />
            <span className="text-sm font-medium">{onlineCount} Online</span>
          </div>
          <div className="flex items-center gap-2 bg-white px-4 py-2 rounded-lg border border-silver-200">
            <PresenceIndicator status="Away" size="sm" />
            <span className="text-sm font-medium">{awayCount} Away</span>
          </div>
          <div className="flex items-center gap-2 bg-white px-4 py-2 rounded-lg border border-silver-200">
            <PresenceIndicator status="Offline" size="sm" />
            <span className="text-sm font-medium">{offlineCount} Offline</span>
          </div>
        </div>

        {/* Filters */}
        <div className="flex flex-wrap gap-4 mb-6">
          <div className="flex items-center gap-2">
            <Filter size={16} className="text-silver-400" />
            <select
              value={statusFilter || ''}
              onChange={(e) => setStatusFilter(e.target.value || null)}
              className="px-3 py-2 border border-silver-200 rounded-lg text-sm bg-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
            >
              {statusOptions.map((opt) => (
                <option key={opt.label} value={opt.value || ''}>
                  {opt.label}
                </option>
              ))}
            </select>
          </div>

          <div>
            <select
              value={departmentFilter || ''}
              onChange={(e) => setDepartmentFilter(e.target.value || null)}
              className="px-3 py-2 border border-silver-200 rounded-lg text-sm bg-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
            >
              <option value="">All Departments</option>
              {departments.map((dept) => (
                <option key={dept} value={dept}>
                  {dept}
                </option>
              ))}
            </select>
          </div>
        </div>

        {/* Team grid */}
        {isLoading && filteredMembers.length === 0 ? (
          <div className="flex items-center justify-center py-12">
            <RefreshCw size={24} className="animate-spin text-silver-400" />
          </div>
        ) : filteredMembers.length === 0 ? (
          <div className="text-center py-12 text-silver-500">
            <Users size={48} className="mx-auto mb-4 text-silver-300" />
            <p>No team members found</p>
            {(statusFilter || departmentFilter) && (
              <button
                onClick={() => {
                  setStatusFilter(null);
                  setDepartmentFilter(null);
                }}
                className="mt-2 text-sm text-blue-600 hover:underline"
              >
                Clear filters
              </button>
            )}
          </div>
        ) : (
          <div className="grid md:grid-cols-2 lg:grid-cols-3 gap-4">
            {filteredMembers.map((member) => (
              <TeamListCard key={member.userId} member={member} />
            ))}
          </div>
        )}
      </main>
    </div>
  );
}
```
  </action>
  <verify>
Run `cd apps/web && npm run build` - should compile without errors.
Run `cd apps/web && npm run dev` and visit http://localhost:3000/team.
Verify:
1. Page shows loading state initially
2. Team members load from API (may be empty if no users have presence sessions)
3. Status filters work
4. Department filter populates from data
5. "Live" indicator shows when WebSocket connected
  </verify>
  <done>
Team page shows real user data from presence API.
Status summary shows counts by Online/Away/Offline.
Filters for status and department work.
Real-time WebSocket connection indicator shows.
Grid displays TeamListCard components.
  </done>
</task>

</tasks>

<verification>
1. Frontend compiles: `cd apps/web && npm run build` succeeds
2. Store works: Open browser devtools, check `usePresenceStore.getState()` in console
3. WebSocket connects: Network tab shows WebSocket connection to /presence
4. Team page loads: Visit /team, see team members (or empty state if no data)
5. Filters work: Change status/department filter, see list update
6. Real-time updates: Have another user change status, see update without refresh
</verification>

<success_criteria>
1. usePresenceStore manages Socket.IO connection with auto-reconnect
2. usePresence hook handles connection lifecycle and heartbeat
3. PresenceIndicator shows correct colors for Online/Away/Offline/Busy
4. TeamListCard displays member info, status, current activity
5. Team page shows real data with filtering by status and department
6. WebSocket events update UI in real-time
7. Frontend compiles and runs without errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-presence-activity/05-03-SUMMARY.md`
</output>
