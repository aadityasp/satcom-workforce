---
phase: 01-foundation-auth
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/src/auth/auth.module.ts
  - apps/api/src/auth/auth.service.ts
  - apps/api/src/auth/strategies/jwt.strategy.ts
  - apps/api/src/auth/strategies/jwt-refresh.strategy.ts
  - apps/api/src/auth/guards/jwt-auth.guard.ts
  - apps/api/src/auth/guards/jwt-refresh.guard.ts
  - apps/api/src/auth/guards/roles.guard.ts
  - apps/api/src/auth/decorators/public.decorator.ts
  - apps/api/src/auth/decorators/roles.decorator.ts
  - apps/api/src/auth/decorators/current-user.decorator.ts
  - apps/api/prisma/schema.prisma
autonomous: true

must_haves:
  truths:
    - "Valid credentials return access + refresh tokens"
    - "Invalid credentials return 401 with same timing"
    - "Refresh token can be exchanged for new access token"
    - "Expired access token returns 401"
    - "Refresh tokens are stored hashed in database"
  artifacts:
    - path: "apps/api/src/auth/strategies/jwt-refresh.strategy.ts"
      provides: "Refresh token validation strategy"
      min_lines: 25
    - path: "apps/api/prisma/schema.prisma"
      provides: "RefreshToken model"
      contains: "model RefreshToken"
  key_links:
    - from: "apps/api/src/auth/auth.service.ts"
      to: "prisma.refreshToken"
      via: "database storage"
      pattern: "prisma\\.refreshToken\\.(create|findUnique)"
    - from: "apps/api/src/auth/strategies/jwt-refresh.strategy.ts"
      to: "apps/api/src/auth/auth.service.ts"
      via: "validate method"
      pattern: "validateRefreshToken"
---

<objective>
Enhance NestJS auth module with dual-token JWT strategy and database-backed refresh tokens.

Purpose: Secure authentication foundation with short-lived access tokens and rotatable refresh tokens stored securely in database (not in-memory).

Output: Enhanced auth service with JWT refresh strategy, database models, and proper token rotation.
</objective>

<execution_context>
@/Users/adityaw/.claude/get-shit-done/workflows/execute-plan.md
@/Users/adityaw/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-auth/01-RESEARCH.md

# Key existing files
@apps/api/src/auth/auth.module.ts
@apps/api/src/auth/auth.service.ts
@apps/api/src/auth/strategies/jwt.strategy.ts
@apps/api/prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add RefreshToken and PasswordResetToken models to Prisma schema</name>
  <files>apps/api/prisma/schema.prisma</files>
  <action>
Add two new models after the DeviceRecord model:

```prisma
/// Refresh tokens for session management
model RefreshToken {
  id        String   @id @default(uuid())
  userId    String
  tokenHash String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
  @@map("refresh_tokens")
}

/// Password reset tokens
model PasswordResetToken {
  id        String    @id @default(uuid())
  userId    String
  tokenHash String    @unique
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime  @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
  @@map("password_reset_tokens")
}
```

Add relations to User model:
- refreshTokens RefreshToken[]
- passwordResetTokens PasswordResetToken[]

Run: `cd apps/api && npx prisma migrate dev --name add_auth_tokens`
  </action>
  <verify>
Run `cd apps/api && npx prisma migrate status` - should show no pending migrations
Run `cd apps/api && npx prisma generate` - should complete without errors
  </verify>
  <done>RefreshToken and PasswordResetToken models exist in schema, migration applied, Prisma client regenerated</done>
</task>

<task type="auto">
  <name>Task 2: Create JWT refresh strategy and enhance auth guards</name>
  <files>
apps/api/src/auth/strategies/jwt-refresh.strategy.ts
apps/api/src/auth/guards/jwt-refresh.guard.ts
apps/api/src/auth/decorators/public.decorator.ts
apps/api/src/auth/decorators/roles.decorator.ts
apps/api/src/auth/decorators/current-user.decorator.ts
  </files>
  <action>
Create jwt-refresh.strategy.ts:
```typescript
import { Injectable } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';
import { ConfigService } from '@nestjs/config';
import { Request } from 'express';

@Injectable()
export class JwtRefreshStrategy extends PassportStrategy(Strategy, 'jwt-refresh') {
  constructor(private configService: ConfigService) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      secretOrKey: configService.get<string>('JWT_REFRESH_SECRET'),
      passReqToCallback: true,
    });
  }

  async validate(req: Request, payload: { sub: string; email: string }) {
    const refreshToken = req.headers.authorization?.split(' ')[1];
    return { userId: payload.sub, email: payload.email, refreshToken };
  }
}
```

Create jwt-refresh.guard.ts:
```typescript
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class JwtRefreshGuard extends AuthGuard('jwt-refresh') {}
```

Create public.decorator.ts:
```typescript
import { SetMetadata } from '@nestjs/common';

export const IS_PUBLIC_KEY = 'isPublic';
export const Public = () => SetMetadata(IS_PUBLIC_KEY, true);
```

Create/update roles.decorator.ts:
```typescript
import { SetMetadata } from '@nestjs/common';
import { UserRole } from '@prisma/client';

export const ROLES_KEY = 'roles';
export const Roles = (...roles: UserRole[]) => SetMetadata(ROLES_KEY, roles);
```

Create current-user.decorator.ts:
```typescript
import { createParamDecorator, ExecutionContext } from '@nestjs/common';

export const CurrentUser = createParamDecorator(
  (data: unknown, ctx: ExecutionContext) => {
    const request = ctx.switchToHttp().getRequest();
    return request.user;
  },
);
```

Update jwt-auth.guard.ts to respect @Public() decorator:
```typescript
import { ExecutionContext, Injectable } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { AuthGuard } from '@nestjs/passport';
import { IS_PUBLIC_KEY } from '../decorators/public.decorator';

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {
  constructor(private reflector: Reflector) {
    super();
  }

  canActivate(context: ExecutionContext) {
    const isPublic = this.reflector.getAllAndOverride<boolean>(IS_PUBLIC_KEY, [
      context.getHandler(),
      context.getClass(),
    ]);
    if (isPublic) {
      return true;
    }
    return super.canActivate(context);
  }
}
```

Update roles.guard.ts:
```typescript
import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { UserRole } from '@prisma/client';
import { ROLES_KEY } from '../decorators/roles.decorator';

@Injectable()
export class RolesGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const requiredRoles = this.reflector.getAllAndOverride<UserRole[]>(ROLES_KEY, [
      context.getHandler(),
      context.getClass(),
    ]);
    if (!requiredRoles) {
      return true;
    }
    const { user } = context.switchToHttp().getRequest();
    return requiredRoles.some((role) => user.role === role);
  }
}
```
  </action>
  <verify>
Run `cd apps/api && npm run build` - should compile without errors
Check that all strategy/guard/decorator files exist
  </verify>
  <done>JWT refresh strategy created, guards updated to support @Public() and @Roles() decorators</done>
</task>

<task type="auto">
  <name>Task 3: Refactor auth service for database-backed refresh tokens</name>
  <files>
apps/api/src/auth/auth.service.ts
apps/api/src/auth/auth.module.ts
  </files>
  <action>
Update auth.service.ts:

1. Remove in-memory refreshTokens Map
2. Add argon2 import (or keep bcrypt for now to avoid breaking changes, but use it properly)
3. Update generateTokens to:
   - Sign refresh token as JWT with JWT_REFRESH_SECRET
   - Hash the token with bcrypt before storing in DB
   - Store in prisma.refreshToken table

4. Update refreshToken method to:
   - Verify JWT signature with JWT_REFRESH_SECRET
   - Look up tokenHash in DB
   - Validate not expired
   - Implement token rotation (delete old, create new)
   - Return new access + refresh tokens

5. Update logout to delete refresh token from DB by userId

6. Add validateRefreshToken method for the strategy to call

Key changes to generateTokens:
```typescript
private async generateTokens(user: { id: string; email: string; role: string }) {
  const payload = { sub: user.id, email: user.email, role: user.role };

  const accessToken = this.jwtService.sign(payload, {
    secret: this.configService.get('JWT_ACCESS_SECRET'),
    expiresIn: this.configService.get('JWT_ACCESS_EXPIRES_IN', '15m'),
  });

  const refreshPayload = { sub: user.id, email: user.email };
  const refreshToken = this.jwtService.sign(refreshPayload, {
    secret: this.configService.get('JWT_REFRESH_SECRET'),
    expiresIn: this.configService.get('JWT_REFRESH_EXPIRES_IN', '7d'),
  });

  // Hash and store refresh token
  const tokenHash = await bcrypt.hash(refreshToken, 10);
  const expiresAt = new Date();
  expiresAt.setDate(expiresAt.getDate() + 7);

  await this.prisma.refreshToken.create({
    data: {
      userId: user.id,
      tokenHash,
      expiresAt,
    },
  });

  return { accessToken, refreshToken, expiresIn: 900 }; // 15 min in seconds
}
```

Update auth.module.ts:
- Import JwtRefreshStrategy
- Import JwtRefreshGuard
- Add them to providers
- Register JwtAuthGuard and RolesGuard as APP_GUARD
  </action>
  <verify>
Run `cd apps/api && npm run build` - should compile without errors
Run `cd apps/api && npm run test` - auth tests should pass (if they exist)
  </verify>
  <done>Auth service stores refresh tokens in database with hashing, implements token rotation on refresh</done>
</task>

</tasks>

<verification>
1. API compiles: `cd apps/api && npm run build`
2. Database migrated: `cd apps/api && npx prisma migrate status`
3. Login returns tokens: `curl -X POST http://localhost:3001/auth/login -H "Content-Type: application/json" -d '{"email":"test@example.com","password":"test123"}'`
4. RefreshToken table has records after login
</verification>

<success_criteria>
- Auth module has dual-token JWT strategy (access + refresh)
- Refresh tokens stored hashed in PostgreSQL (not in-memory)
- Token rotation implemented (old token deleted on refresh)
- @Public() decorator marks routes as unauthenticated
- @Roles() decorator enforces role-based access
- All guards use Reflector for metadata checking
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-auth/01-01-SUMMARY.md`
</output>
