---
phase: 01-foundation-auth
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/src/middleware.ts
  - apps/web/src/lib/auth.ts
  - apps/web/src/lib/api.ts
  - apps/web/src/app/(auth)/layout.tsx
  - apps/web/src/app/(dashboard)/layout.tsx
  - apps/web/src/store/auth-store.ts
autonomous: true

must_haves:
  truths:
    - "Unauthenticated users are redirected to /login"
    - "Authenticated users accessing /login are redirected to dashboard"
    - "Role-restricted routes redirect unauthorized users"
    - "Session persists across page refresh"
  artifacts:
    - path: "apps/web/src/middleware.ts"
      provides: "Route protection and redirects"
      min_lines: 40
    - path: "apps/web/src/lib/auth.ts"
      provides: "Auth utilities for token management"
      min_lines: 30
  key_links:
    - from: "apps/web/src/middleware.ts"
      to: "JWT verification"
      via: "jose library"
      pattern: "jwtVerify"
    - from: "apps/web/src/lib/auth.ts"
      to: "apps/web/src/lib/api.ts"
      via: "token refresh"
      pattern: "refreshToken"
---

<objective>
Implement Next.js middleware for route protection with role-based access control.

Purpose: Secure frontend routes by validating JWT tokens in middleware, redirecting unauthenticated users to login, and enforcing role-based access to admin/HR/manager sections.

Output: Working middleware that protects dashboard routes and redirects based on auth state and user role.
</objective>

<execution_context>
@/Users/adityaw/.claude/get-shit-done/workflows/execute-plan.md
@/Users/adityaw/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-auth/01-RESEARCH.md

# Existing web app files
@apps/web/src/app/layout.tsx
@apps/web/src/lib/api.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create auth utilities and token management</name>
  <files>
apps/web/src/lib/auth.ts
apps/web/src/lib/api.ts
  </files>
  <action>
Create apps/web/src/lib/auth.ts:
```typescript
import { jwtVerify, type JWTPayload } from 'jose';

export interface TokenPayload extends JWTPayload {
  sub: string;
  email: string;
  role: 'Employee' | 'Manager' | 'HR' | 'SuperAdmin';
}

export interface AuthTokens {
  accessToken: string;
  refreshToken: string;
  expiresIn: number;
}

export interface User {
  id: string;
  email: string;
  role: TokenPayload['role'];
  profile?: {
    firstName: string;
    lastName: string;
    designation?: string;
    avatarUrl?: string;
  };
}

/**
 * Verify JWT token and extract payload
 */
export async function verifyToken(token: string): Promise<TokenPayload | null> {
  try {
    const secret = new TextEncoder().encode(process.env.JWT_ACCESS_SECRET);
    const { payload } = await jwtVerify(token, secret);
    return payload as TokenPayload;
  } catch {
    return null;
  }
}

/**
 * Check if user has required role
 */
export function hasRole(userRole: string, allowedRoles: string[]): boolean {
  // Role hierarchy: SuperAdmin > HR > Manager > Employee
  const roleHierarchy: Record<string, number> = {
    SuperAdmin: 4,
    HR: 3,
    Manager: 2,
    Employee: 1,
  };

  const userLevel = roleHierarchy[userRole] || 0;
  return allowedRoles.some(role => roleHierarchy[role] <= userLevel);
}

/**
 * Role-based route access configuration
 */
export const routeRoles: Record<string, string[]> = {
  '/admin': ['SuperAdmin'],
  '/hr': ['SuperAdmin', 'HR'],
  '/team': ['SuperAdmin', 'HR', 'Manager'],
  '/dashboard': ['SuperAdmin', 'HR', 'Manager', 'Employee'],
  '/timesheets': ['SuperAdmin', 'HR', 'Manager', 'Employee'],
  '/leaves': ['SuperAdmin', 'HR', 'Manager', 'Employee'],
  '/chat': ['SuperAdmin', 'HR', 'Manager', 'Employee'],
};

/**
 * Get the appropriate dashboard route for a role
 */
export function getDashboardRoute(role: string): string {
  switch (role) {
    case 'SuperAdmin':
      return '/admin';
    case 'HR':
      return '/hr';
    case 'Manager':
      return '/team';
    default:
      return '/dashboard';
  }
}
```

Update apps/web/src/lib/api.ts to add auth endpoints:
```typescript
const API_BASE = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001';

export interface LoginRequest {
  email: string;
  password: string;
  deviceFingerprint?: string;
}

export interface LoginResponse {
  accessToken: string;
  refreshToken: string;
  expiresIn: number;
  user: {
    id: string;
    email: string;
    role: string;
    profile?: {
      firstName: string;
      lastName: string;
      designation?: string;
      avatarUrl?: string;
    };
  };
  requiresOtp?: boolean;
}

export interface RefreshResponse {
  accessToken: string;
  expiresIn: number;
}

export async function login(data: LoginRequest): Promise<LoginResponse> {
  const response = await fetch(`${API_BASE}/auth/login`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
    credentials: 'include',
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.message || 'Login failed');
  }

  return response.json();
}

export async function refreshAccessToken(refreshToken: string): Promise<RefreshResponse> {
  const response = await fetch(`${API_BASE}/auth/refresh`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${refreshToken}`,
    },
    credentials: 'include',
  });

  if (!response.ok) {
    throw new Error('Token refresh failed');
  }

  return response.json();
}

export async function logout(refreshToken?: string): Promise<void> {
  await fetch(`${API_BASE}/auth/logout`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ refreshToken }),
    credentials: 'include',
  });
}
```

Install jose if not present: `cd apps/web && npm install jose`
  </action>
  <verify>
Run `cd apps/web && npm run build` - should compile without type errors
Check that jose is in package.json dependencies
  </verify>
  <done>Auth utilities created with token verification, role checking, and API functions</done>
</task>

<task type="auto">
  <name>Task 2: Create Next.js middleware for route protection</name>
  <files>apps/web/src/middleware.ts</files>
  <action>
Create apps/web/src/middleware.ts:
```typescript
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';
import { jwtVerify } from 'jose';

// Routes that don't require authentication
const publicPaths = ['/login', '/forgot-password', '/reset-password'];

// Role-based route access
const roleRoutes: Record<string, string[]> = {
  '/admin': ['SuperAdmin'],
  '/hr': ['SuperAdmin', 'HR'],
  '/team': ['SuperAdmin', 'HR', 'Manager'],
};

// Get dashboard route based on role
function getDashboardForRole(role: string): string {
  switch (role) {
    case 'SuperAdmin': return '/admin';
    case 'HR': return '/hr';
    case 'Manager': return '/team';
    default: return '/dashboard';
  }
}

export async function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl;

  // Skip API routes and static files
  if (
    pathname.startsWith('/api') ||
    pathname.startsWith('/_next') ||
    pathname.includes('.') // Static files
  ) {
    return NextResponse.next();
  }

  // Get access token from cookie
  const accessToken = request.cookies.get('access_token')?.value;

  // Check if path is public
  const isPublicPath = publicPaths.some(path => pathname.startsWith(path));

  // No token - redirect to login for protected routes
  if (!accessToken) {
    if (isPublicPath) {
      return NextResponse.next();
    }
    const loginUrl = new URL('/login', request.url);
    loginUrl.searchParams.set('redirect', pathname);
    return NextResponse.redirect(loginUrl);
  }

  // Verify token
  try {
    const secret = new TextEncoder().encode(process.env.JWT_ACCESS_SECRET);
    const { payload } = await jwtVerify(accessToken, secret);
    const userRole = payload.role as string;

    // Authenticated user accessing public path - redirect to dashboard
    if (isPublicPath) {
      return NextResponse.redirect(new URL(getDashboardForRole(userRole), request.url));
    }

    // Check role-based access
    for (const [route, allowedRoles] of Object.entries(roleRoutes)) {
      if (pathname.startsWith(route)) {
        if (!allowedRoles.includes(userRole)) {
          // Redirect to appropriate dashboard instead of unauthorized page
          return NextResponse.redirect(new URL(getDashboardForRole(userRole), request.url));
        }
        break;
      }
    }

    // Add user info to request headers for server components
    const response = NextResponse.next();
    response.headers.set('x-user-id', payload.sub as string);
    response.headers.set('x-user-role', userRole);
    response.headers.set('x-user-email', payload.email as string);
    return response;

  } catch (error) {
    // Invalid/expired token - clear cookie and redirect to login
    const response = NextResponse.redirect(new URL('/login', request.url));
    response.cookies.delete('access_token');
    response.cookies.delete('refresh_token');
    return response;
  }
}

export const config = {
  matcher: [
    /*
     * Match all request paths except:
     * - api (API routes)
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     */
    '/((?!api|_next/static|_next/image|favicon.ico).*)',
  ],
};
```
  </action>
  <verify>
Run `cd apps/web && npm run build` - middleware should compile
Run `cd apps/web && npm run lint` - no linting errors
  </verify>
  <done>Middleware protects routes, redirects unauthenticated users, enforces role-based access</done>
</task>

<task type="auto">
  <name>Task 3: Create auth store and update login page</name>
  <files>
apps/web/src/store/auth-store.ts
apps/web/src/app/login/page.tsx
  </files>
  <action>
Create apps/web/src/store/auth-store.ts using zustand (if installed) or simple React context:
```typescript
import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import type { User, AuthTokens } from '@/lib/auth';

interface AuthState {
  user: User | null;
  accessToken: string | null;
  refreshToken: string | null;
  isAuthenticated: boolean;

  setAuth: (user: User, tokens: AuthTokens) => void;
  clearAuth: () => void;
  updateAccessToken: (token: string) => void;
}

export const useAuthStore = create<AuthState>()(
  persist(
    (set) => ({
      user: null,
      accessToken: null,
      refreshToken: null,
      isAuthenticated: false,

      setAuth: (user, tokens) => {
        // Also set cookies for middleware
        document.cookie = `access_token=${tokens.accessToken}; path=/; max-age=${tokens.expiresIn}; SameSite=Lax`;
        document.cookie = `refresh_token=${tokens.refreshToken}; path=/; max-age=${60 * 60 * 24 * 7}; SameSite=Lax`;

        set({
          user,
          accessToken: tokens.accessToken,
          refreshToken: tokens.refreshToken,
          isAuthenticated: true,
        });
      },

      clearAuth: () => {
        // Clear cookies
        document.cookie = 'access_token=; path=/; max-age=0';
        document.cookie = 'refresh_token=; path=/; max-age=0';

        set({
          user: null,
          accessToken: null,
          refreshToken: null,
          isAuthenticated: false,
        });
      },

      updateAccessToken: (token) => {
        document.cookie = `access_token=${token}; path=/; max-age=900; SameSite=Lax`;
        set({ accessToken: token });
      },
    }),
    {
      name: 'auth-storage',
      partialize: (state) => ({
        user: state.user,
        refreshToken: state.refreshToken,
        isAuthenticated: state.isAuthenticated,
      }),
    }
  )
);
```

Update apps/web/src/app/login/page.tsx to use the new auth flow:
- On successful login, call useAuthStore().setAuth()
- Redirect to appropriate dashboard based on role
- Show loading state during redirect

If zustand not installed: `cd apps/web && npm install zustand`
  </action>
  <verify>
Run `cd apps/web && npm run build` - should compile
Check that zustand is in package.json
  </verify>
  <done>Auth store manages tokens and user state, login page integrates with new auth flow</done>
</task>

</tasks>

<verification>
1. Build succeeds: `cd apps/web && npm run build`
2. Start dev server: `cd apps/web && npm run dev`
3. Visit http://localhost:3000/dashboard without auth - should redirect to /login
4. Visit http://localhost:3000/login while authenticated - should redirect to dashboard
5. Employee accessing /admin should redirect to /dashboard
</verification>

<success_criteria>
- Middleware intercepts all non-API routes
- Unauthenticated users redirected to /login with redirect param
- Authenticated users on /login redirect to role-appropriate dashboard
- Role-restricted routes (/admin, /hr, /team) enforce access
- Tokens stored in cookies for middleware access
- Auth state persists across page refresh via zustand
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-auth/01-02-SUMMARY.md`
</output>
